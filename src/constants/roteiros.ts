export const roteiros = [
  {
    "id": "2c3ef1fe-2a19-4a49-b5d9-a9d4c7e39f4c",
    "titulo": "Preparar o Ferramental e Ambiente",
    "nivel": "iniciante",
    "ferramenta": "Terraform",
    "conteudo": "##CENA 1 – ABERTURA\n====INT. ESCRITÓRIO - DIA====\nVisão panorâmica de um escritório de tecnologia moderno, com monitores exibindo código e diagramas de nuvem conectados. A câmera foca em um teclado e tela de computador, indicando que vamos iniciar uma jornada técnica.\n\n**INSTRUTOR:** \nOlá e bem-vindos à nossa série de tutoriais sobre **Terraform**! Neste primeiro episódio, vamos preparar todo o ferramental e ambiente necessários para começarmos a usar o Terraform. Infraestrutura como código é uma abordagem poderosa, e o Terraform é uma das principais ferramentas para isso. Antes de criar recursos em nuvem, precisamos configurar nosso ambiente de trabalho. Vamos garantir que tudo esteja instalado e configurado corretamente, desde o Terraform em si até as credenciais de acesso à nuvem.”\n\nClose-up na tela do computador mostrando o logotipo do Terraform e ícones de provedor de nuvem (AWS, Azure). A atmosfera é de introdução, com música ambiente leve indicando início de jornada.\n\n**INSTRUTOR:** \nNeste tutorial, você verá como instalar o Terraform, configurar suas credenciais de provedor de nuvem e verificar se o seu ambiente está pronto para uso. Vamos começar nossa aventura em infraestrutura como código preparando o terreno para os próximos vídeos.\n===encerramento da cena===\n---\n## CENA 2 – CONFIGURANDO AS FERRAMENTAS\n====INT. TELA DO COMPUTADOR - DIA====\nTransição para a tela do computador. O instrutor navega pelo site oficial do Terraform. Vemos o cursor destacando a seção de download.\n  \n**INSTRUTOR:**\nPrimeiro, precisamos **instalar o Terraform** em nossa máquina. Vamos acessar o site oficial do Terraform (da HashiCorp) e baixar o pacote adequado para o seu sistema operacional. Após o download, extraia o executável e coloque-o em um local acessível, de preferência incluído no PATH do sistema para poder chamar o comando `terraform` de qualquer lugar.”\n\nNa tela, o instrutor abre um terminal. Digita comandos para verificar a versão do Terraform instalada.\n  \n**INSTRUTOR:**\nCom o Terraform instalado, vamos confirmar se tudo correu bem. No terminal, vou executar: `terraform -v`. Isso deve exibir a versão do Terraform instalada, confirmando que a ferramenta está pronta para uso.” \n \nO terminal exibe a versão do Terraform, por exemplo: Terraform v1.xx.x.\n  \n**INSTRUTOR:**\nÓtimo, Terraform instalado com sucesso! Agora temos a ferramenta principal configurada.\n\n===encerramento da cena===\n---\n## CENA 3 – PREPARANDO O AMBIENTE\n====INT. TELA DO COMPUTADOR - DIA====\nO ambiente de desenvolvimento é mostrado. Um editor de código aberto aguardando comandos, ao lado de um terminal. O instrutor agora fala sobre provedores e credenciais.\n\n**INSTRUTOR:** \nAntes de usar o Terraform para criar infraestrutura, precisamos configurar nosso ambiente de nuvem. O Terraform **se comunica com provedores de nuvem** como AWS, Azure, Google Cloud, entre outros, por meio de plugins chamados _providers_. Neste tutorial, vamos usar a **AWS** como exemplo (mas você pode usar Azure ou outra nuvem semelhante, contanto que tenha as credenciais apropriadas). Então, vamos garantir que temos uma conta na AWS e gerar credenciais de acesso (Access Key ID e Secret Access Key) para o Terraform usar.”\n\nNa tela, o instrutor exibe a interface da AWS para criação de credenciais ou menciona o arquivo de credenciais local.\n\n**INSTRUTOR:**\nSe você já configurou o AWS CLI antes, o Terraform pode reutilizar as credenciais salvas em `~/.aws/credentials` (no Windows, na pasta de usuário\\.aws\\credentials). Caso contrário, você pode exportar suas credenciais como variáveis de ambiente:`AWS_ACCESS_KEY_ID` e `AWS_SECRET_ACCESS_KEY`, ou configurar um perfil padrão. O importante é que o Terraform tenha permissão para agir em sua conta de nuvem.\n\nClose-up no editor de texto, onde o instrutor começa a criar um diretório do projeto e um arquivo de configuração inicial.\n \n**INSTRUTOR:** \nVamos criar uma pasta para nosso projeto Terraform, por exemplo `terraform-project`. Dentro dela, vamos criar nosso primeiro arquivo de configuração: `main.tf`. Nele, definiremos qual provedor vamos usar e quaisquer configurações iniciais.\n\nO instrutor digita no editor um exemplo mínimo de arquivo main.tf:\n\n```hcl\nprovider \"aws\" {\n  region = \"us-east-1\"\n}\n```\n\n**INSTRUTOR:** \nAqui, estamos dizendo ao Terraform que usaremos o provedor `aws` e definindo a região para `us-east-1` (você pode escolher a região que preferir ou que faça sentido para seu caso). Note que não incluímos as credenciais no arquivo – o Terraform vai buscar as credenciais do AWS CLI configuradas ou variáveis de ambiente, conforme acabamos de preparar. Nunca é bom colocar segredos diretamente no código por questões de segurança.\n\n===encerramento da cena===\n---\n## CENA 4 – TESTANDO O AMBIENTE\n====INT. TELA DO COMPUTADOR - DIA====\nAgora o terminal é exibido ao lado do código, pronto para executar o Terraform. A câmera destaca o entusiasmo do primeiro uso.\n\n**INSTRUTOR:** \nCom o provedor configurado, vamos inicializar o Terraform no diretório do projeto. No terminal, executamos o comando de inicialização:\n\n```bash\nterraform init\n```\n\nO terminal mostra o progresso do `terraform init`, baixando o plugin do provedor AWS.\n\n**INSTRUTOR:**\nO comando `terraform init` prepara o ambiente de trabalho do Terraform naquele diretório. Ele baixa o plugin do provedor AWS (e quaisquer outros providers definidos) e inicializa um diretório oculto chamado `.terraform` com esses plugins. Como vemos, o Terraform fez o download do provider AWS e agora nosso projeto está inicializado.\n\n**INSTRUTOR:**\nTudo pronto para começar! Nosso ambiente está configurado: Terraform instalado, credenciais de nuvem configuradas e provedor inicializado. No próximo tutorial, usaremos esse ambiente para criar nosso primeiro recurso de infraestrutura na nuvem. Até lá, certifique-se de que seu ambiente esteja funcionando – se o `terraform init` rodou sem erros e o `terraform -v` exibiu a versão, você está no caminho certo. Nos vemos no próximo episódio, onde colocaremos o Terraform em ação!\n\nCena de encerramento mostra o instrutor salvando o arquivo, a tela escurecendo lentamente enquanto o logotipo do Terraform aparece novamente, indicando fim do primeiro tutorial.\n\n**INSTRUTOR:**\nObrigado por acompanhar este passo inicial. Nos vemos em breve para começarmos a criar infraestrutura com Terraform!\n===fade out==="
  },
  {
    "id": "337e9308-5679-4976-a823-4a0a2b80f485",
    "titulo": "Funções básicas",
    "nivel": "iniciante",
    "ferramenta": "Terraform",
    "conteudo": "## CENA 1 – RECAPITULAÇÃO\n====INT. TELA DO COMPUTADOR - DIA====\nUma vinheta de “Anteriormente na série Terraform” surge. Imagens breves mostram a instalação do Terraform e a configuração do provedor AWS.\n\n**INSTRUTOR:**\nNosso primeiro tutorial foi dedicado a preparar o ambiente: instalamos o Terraform e configuramos as credenciais e o provedor AWS para nosso projeto. Com tudo pronto, chegou a hora de utilizar o Terraform de verdade. Vamos relembrar: deixamos nosso `main.tf` configurado com o provedor e a região, após rodar um `terraform init` bem-sucedido. Agora é hora de criar recursos de infraestrutura na nuvem usando o Terraform.\n===encerramento da cena===\n---\n## CENA 2 – ABERTURA\n====INT. TELA DO COMPUTADOR - DIA====\nTransição para a cena atual: vemos um diagrama simples de um servidor sendo criado em uma nuvem quando acionado por código. A ideia de “codificar infraestrutura” fica visualmente clara.\n  \n**INSTRUTOR:**\nBem-vindo ao Tutorial 2! Hoje vamos explorar as **funções básicas** do Terraform na prática. Isso inclui escrever nossa primeira configuração real de infraestrutura e usar os comandos fundamentais do Terraform: plan, apply e destroy. Em outras palavras, vamos criar nosso primeiro recurso na nuvem usando código Terraform. Prepare-se para ver a infraestrutura ganhando vida a partir de configurações escritas em um arquivo .tf.\n\nO título “Funções Básicas” aparece na tela sobreposto a imagens de terminal executando comandos.\n  \n**INSTRUTOR:**\nVocê vai aprender como o Terraform aplica as configurações, como revisar alterações planejadas antes de executá-las e até como remover a infraestrutura quando ela não for mais necessária, tudo de forma automatizada. Vamos colocar a mão na massa e entender o ciclo básico de uso do Terraform.\n===encerramento da cena===\n---\n## CENA 3 – ESCREVENDO A PRIMEIRA CONFIGURAÇÃO\n====INT. TELA DO COMPUTADOR - DIA====\nNo editor de código `main.tf`, o instrutor começa a definir um recurso real. A câmera foca no texto conforme ele é digitado.\n\n**INSTRUTOR:**\nVamos começar definindo um recurso de exemplo. No nosso arquivo `main.tf`, logo abaixo do bloco de provider, vamos adicionar uma configuração de recurso. Como exemplo, criaremos uma instância EC2 na AWS.\n\nO instrutor digita o bloco de recurso Terraform:\n\n```hcl\nresource \"aws_instance\" \"meu_servidor\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n  tags = {\n    Name = \"ServidorExemplo\"\n  }\n}\n```\n\n**INSTRUTOR:**\nAqui, definimos um recurso do tipo `aws_instance` chamado `meu_servidor`. Preenchemos alguns atributos obrigatórios: a AMI (Amazon Machine Image) com um ID de exemplo e o tipo da instância. Nesse caso, usamos uma AMI genérica (por exemplo, do Amazon Linux) e um tamanho `t2.micro` que é elegível para a camada gratuita da AWS. Adicionamos também uma tag Name para identificar a instância. Lembre-se: a escolha da AMI e outros detalhes dependem do seu caso; use valores que façam sentido para você (como outra AMI ou tamanho de instância) se necessário.\n\n**INSTRUTOR:** \nSalvamos o arquivo com o recurso. Antes de criar qualquer coisa, é importante entender o que fizemos: descrevemos em código algo que queremos que exista na nuvem (um servidor EC2). Mas nada foi criado ainda. O Terraform primeiro nos permite planejar a mudança, para prever o que acontecerá.\n===encerramento da cena===\n---\n## CENA 4 – PLAN: REVISANDO MUDANÇAS\n====INT. TELA DO COMPUTADOR - DIA====\nTela dividida: à esquerda o terminal, à direita o código Terraform que acabamos de escrever, para referência. O instrutor prepara a execução do comando plan.\n \n**INSTRUTOR:**\nAgora entra em cena um dos comandos básicos do Terraform: `terraform plan`. Esse comando analisa a configuração que escrevemos, verifica o estado atual da infraestrutura (no momento, nenhuma instância existe ainda) e então gera um **plano** mostrando o que será criado, modificado ou destruído.\n\nO instrutor digita no terminal:\n\n```bash\nterraform plan\n```\n\nO terminal exibe o resultado do plan. Vemos listados em verde os recursos a ser adicionados.\n  \n**INSTRUTOR:**\nO resultado do `terraform plan` está nos dizendo o que acontecerá se aplicarmos a configuração. Deve mostrar algo como: `+ aws_instance.meu_servidor will be created`, juntamente com os detalhes (AMI, tipo, etc). O símbolo `+` indica criação de recurso. Como esse recurso ainda não existe, o Terraform planeja adicioná-lo. Não há itens com `-` (remoção) ou `~` (alteração) porque não temos nada existente para remover ou alterar – é a primeira aplicação.\n\n**INSTRUTOR:** \nRevisar o plano é uma etapa essencial. Sempre que possível, cheque se o que o Terraform planeja condiz com o que você espera. Dessa forma evitamos surpresas. Tudo parecendo correto, vamos em frente e criar a instância.\n===encerramento da cena===\n---\n## CENA 5 – APPLY: PROVISIONANDO INFRAESTRUTURA  \n====INT. TELA DO COMPUTADOR - DIA====\nClose no terminal enquanto o instrutor confirma a aplicação. Tom animado, pois é o momento em que a mágica acontece.\n\n**INSTRUTOR:** \nCom o plano revisado, vamos executar `terraform apply` para concretizar as mudanças.\n\n```bash\nterraform apply\n```\n\nO Terraform exibe novamente o plano e aguarda confirmação.\n \n**INSTRUTOR:**\nAo rodar o apply, por padrão o Terraform vai nos mostrar o plano novamente para confirmação. Ele pedirá que confirmemos digitando ‘yes’ para prosseguir. Isso é uma segurança para evitarmos aplicar mudanças acidentalmente. Vamos confirmar.\n\nO instrutor digita “yes”. O terminal começa a exibir a criação do recurso: mensagens mostrando que a instância está sendo criada.\n  \n**INSTRUTOR:**\nO Terraform está agora comunicando-se com a AWS para criar a instância EC2 que descrevemos. Esse processo pode levar alguns segundos. Assim que terminar, veremos uma mensagem de sucesso.\n\nNo terminal aparece: `Apply complete! Resources: 1 added, 0 changed, 0 destroyed.`\n  \n**INSTRUTOR:** \nPronto! O Terraform criou nosso recurso. A mensagem indica que 1 recurso foi adicionado. Agora temos, na AWS, uma instância EC2 em execução conforme especificamos. Se abrirmos o console da AWS, encontraremos essa instância _ServidorExemplo_ na região escolhida.\n\nNa tela, uma rápida captura ou imagem ilustrativa da instância listada no AWS Management Console para reforçar a veracidade.\n \n**INSTRUTOR:** \nVejam, nossa instância está lá na nuvem, criada automaticamente pelo Terraform. Legal, não é? Com alguns comandos, descrevemos e provisionamos infraestrutura de forma reproduzível. Essa é a essência do IaC (Infraestrutura como Código).\n===encerramento da cena===\n---\n## CENA 6 – OUTROS COMANDOS BÁSICOS E LIMPEZA\n====INT. TELA DO COMPUTADOR - DIA====\nO instrutor agora fala sobre o ciclo de vida básico e como encerrar recursos quando necessário.\n \n**INSTRUTOR:**\nUsamos `plan` e `apply`, que são o coração do uso diário do Terraform. Vamos falar de mais um comando fundamental: o `terraform destroy`. Ele serve para destruir a infraestrutura criada pelo Terraform quando ela não for mais necessária, liberando recursos e evitando custos.\n\nNo terminal, o instrutor executa:\n\n```bash\nterraform destroy\n```\n\n**INSTRUTOR:** \nAssim como no apply, o Terraform vai mostrar um plano – dessa vez indicando a remoção do recurso com `-` – e pedirá confirmação. Digite ‘yes’ para confirmar a destruição.\n\nApós confirmação, o terminal mostra a remoção: `Destroy complete! Resources: 1 destroyed.`\n\n**INSTRUTOR:** \nNossa instância foi terminada. É importante conhecer o `destroy` para praticar em ambiente de teste ou limpar recursos que não precisamos mais. Lembre-se: use com cuidado em ambientes de produção, pois ele realmente remove o que foi criado pelo Terraform.\n\n**INSTRUTOR:**\nAlém desses, o Terraform possui outros comandos úteis. Por exemplo: `terraform fmt` formata seu código .tf, `terraform validate` verifica se a sintaxe e configurações são válidas, e `terraform show` mostra detalhes dos recursos gerenciados. Com o tempo, você vai explorá-los, mas os que usamos – init, plan, apply, destroy – formam o fluxo básico de trabalho.\n===encerramento da cena===\n---\n## CENA 7 – ENCERRAMENTO\n====INT. TELA DO COMPUTADOR - DIA====\nO ambiente de desenvolvimento é visto de longe enquanto o instrutor conclui. A sensação é de conquista do primeiro objetivo.\n\n**INSTRUTOR:**\nNeste tutorial, aprendemos a **usar o Terraform na prática**: escrevemos um recurso, planejamos a mudança e aplicamos para criar uma instância EC2 na AWS, depois aprendemos a destruir o recurso. Essas são as funções básicas do Terraform que utilizaremos constantemente. Parabéns – você provisionou sua primeira infraestrutura como código!\n\n**INSTRUTOR:**\nNo próximo tutorial, vamos melhorar nosso código usando **variáveis e outputs** para torná-lo mais flexível e informativo. Até lá, experimente mudar alguns valores (como a tag, ou o tipo da instância) e rodar `plan`/`apply` novamente para ver como o Terraform detecta e aplica mudanças. Vejo você no próximo episódio!\n\nTela escurece com a logo do Terraform, encerrando o tutorial 2.\n===fade out==="
  },
  {
    "id": "4f5a12f6-66cb-4504-b2fa-bdbcecc3c1de",
    "titulo": "Variáveis e outputs",
    "nivel": "iniciante",
    "ferramenta": "Terraform",
    "conteudo": "## CENA 1 – RECAPITULAÇÃO\n====INT. TELA DO COMPUTADOR - DIA====\nImagens dos tutoriais anteriores passam rapidamente: a instância sendo criada no terminal, código Terraform no editor.\n\n**INSTRUTOR:**\nAté agora, configuramos nosso ambiente e criamos nossa primeira instância EC2 usando Terraform. Vimos como funcionam os comandos básicos `plan`, `apply` e `destroy`. No código, porém, colocamos valores fixos – como o ID da AMI, tipo da instância, etc. No tutorial de hoje, vamos aprender a tornar nosso código **mais flexível e reutilizável**. Também veremos como extrair informações do Terraform após a criação dos recursos. Preparado? Então vamos lá!\n===encerramento da cena===\n---\n## CENA 2 – ABERTURA\n====INT. TELA DO COMPUTADOR - DIA====\nCena de abertura mostra um trecho de código com valores repetidos sendo transformados em variáveis genéricas, simbolizando flexibilidade. Em seguida, mostra um output exibindo um resultado (como um IP) após a execução.\n\n**INSTRUTOR:**\nBem-vindo ao Tutorial 3! Hoje o foco é em **Variáveis e Outputs** no Terraform. Imagine ter que alterar a região ou o tipo de instância em vários lugares do código – seria trabalhoso se tudo estiver codificado diretamente. As variáveis resolvem isso, permitindo parametrizar nossa configuração. E os _outputs_ nos ajudam a obter informações dos recursos criados, como IDs, IPs, ou outros detalhes, de forma fácil e organizada depois do `apply`.\n\n**INSTRUTOR:**\nVamos refatorar nosso código para usar variáveis ao invés de valores fixos, seguindo boas práticas. Além disso, vamos configurar outputs para ver, por exemplo, o IP da instância criada sem precisar ir até o console da AWS. Isso torna nossa infraestrutura como código mais dinâmica e informativa.\n===encerramento da cena===\n---\n## CENA 3 – POR QUE USAR VARIÁVEIS?\n====INT. ESCRITÓRIO - DIA====\nO instrutor aparece virtualmente diante de um quadro branco digital, onde está escrito “Manutenção e Reutilização”. Ele aponta para um exemplo de código repetitivo.\n \n**INSTRUTOR:**\nAntes de colocar a mão no código, vale entender a motivação: variáveis nos permitem evitar repetição e facilitar manutenção. Pense assim: se quisermos reutilizar nosso código para criar instâncias em outra região ou com outro nome, basta mudar o valor de uma variável ao invés de procurar e substituir em todo o arquivo. Variáveis são _placeholders_ para valores que podem mudar conforme o contexto ou uso do módulo.”\n\nNo quadro, o nome da cidade em um texto repetido é substituído por uma variável, em uma analogia simples.\n  \n**INSTRUTOR:**\nÉ como em programação tradicional: ao invés de escrever o mesmo valor múltiplas vezes, usamos uma variável. Alterando o valor da variável em um único lugar, o restante do código reflete essa mudança automaticamente. Isso traz flexibilidade e reduz erros.”\n===encerramento da cena===\n---\n## CENA 4 – DEFININDO VARIÁVEIS\n====INT. TELA DO COMPUTADOR - DIA====\nDe volta ao editor de código. O instrutor cria um novo arquivo chamado `variables.tf` ao lado do `main.tf`.\n  \n**INSTRUTOR:**\nVamos criar um arquivo separado para declarar nossas variáveis – embora pudéssemos colocá-las no mesmo arquivo, é uma boa prática organizar em um arquivo `variables.tf`. Vamos extrair alguns parâmetros do nosso `aws_instance` para variáveis. Por exemplo: ID da AMI, tipo da instância, e talvez o nome de tag.”\n\nO instrutor digita as definições de variáveis no arquivo variables.tf:\n\n```hcl\nvariable \"instance_ami\" {\n  description = \"ID da AMI para a instância EC2\"\n  type        = string\n  default     = \"ami-0c55b159cbfafe1f0\"\n}\n\nvariable \"instance_type\" {\n  description = \"Tipo da instância EC2\"\n  type        = string\n  default     = \"t2.micro\"\n}\n\nvariable \"instance_name\" {\n  description = \"Nome (Tag Name) da instância\"\n  type        = string\n  default     = \"ServidorExemplo\"\n}\n```\n\n**INSTRUTOR:**\nAqui definimos três variáveis: `instance_ami`, `instance_type` e `instance_name`. Para cada variável, fornecemos: uma descrição útil, o tipo esperado (usamos string nesses casos) e até um valor padrão (`default`). O valor padrão é opcional – se não fornecido, o Terraform irá exigir que você passe um valor ao aplicar. Mas com defaults, nosso código pode rodar sem configurações adicionais, usando esses valores padrões.”\n\nO instrutor destaca brevemente outras possibilidades:\n  \n**INSTRUTOR:**\nAlém de strings, variáveis podem ser de vários tipos: número, booleanos, listas, mapas e até objetos complexos. Isso nos dá liberdade para estruturar entradas. Também podemos marcar variáveis como sensíveis (para esconder em logs) ou adicionar validações, mas por ora manteremos simples.”\n===encerramento da cena===\n---\n## CENA 5 – UTILIZANDO VARIÁVEIS NO CÓDIGO\n====INT. TELA DO COMPUTADOR - DIA====\nO foco retorna ao arquivo `main.tf`. O instrutor modifica o bloco do recurso aws_instance para usar as variáveis definidas.\n\n**INSTRUTOR:**\nAgora vamos **substituir os valores fixos pelas variáveis** correspondentes dentro do recurso.”\n\nNo `main.tf`, o instrutor altera o recurso:\n\n```hcl\nresource \"aws_instance\" \"meu_servidor\" {\n  ami           = var.instance_ami\n  instance_type = var.instance_type\n  tags = {\n    Name = var.instance_name\n  }\n}\n```\n\n**INSTRUTOR:**\nNote a sintaxe: usamos `var.<nome_da_variável>` para referenciar o valor da variável no código. Dessa forma, o ami da instância passa a ser o valor de `instance_ami`, e assim por diante. Agora podemos facilmente mudar qual AMI usar ou o nome da instância alterando apenas os valores das variáveis (ou sobrescrevendo-os ao executar o Terraform, como veremos).”\n===encerramento da cena===\n---\n## CENA 6 – APLICANDO VARIÁVEIS\n====INT. TELA DO COMPUTADOR - DIA====\nNo terminal, o instrutor prepara um plan/apply para testar as mudanças.\n  \n**INSTRUTOR:**\nVamos verificar se tudo está funcionando com as variáveis. Ao rodar `terraform plan` agora, teoricamente não deveria mudar nada na infraestrutura real já existente – afinal, usamos os mesmos valores mas via variáveis. Porém, o Terraform pode mostrar alterações no plano se interpretar que algo mudou, especialmente no campo tag Name se foi adaptado. Vamos conferir.”\n\nExecuta `terraform plan`.\n \nO output mostra se há alguma mudança pendente. Idealmente, se os valores default são os mesmos antes, deve indicar “No changes” ou apenas um pequeno ajuste no nome se trocou de literal para variável.\n \n**INSTRUTOR:**\nSe configuramos tudo corretamente, o plan não indicará mudanças significativas (ou talvez apenas um pequeno ajuste de tag, dependendo de como o Terraform lida com o valor de tag via variável). Isso significa que as variáveis estão funcionando e representando os mesmos valores de antes. Vamos em frente e aplicar de novo só para garantir que o Terraform aceite nossa refatoração.”\n\nExecuta `terraform apply -auto-approve` (nesse caso, podemos automatizar a aprovação para agilizar, já que esperamos nenhuma mudança real).\n \n**INSTRUTOR:**\nÓtimo, o Terraform rodou com variáveis sem problemas. Repare que poderíamos agora alterar, por exemplo, o tipo de instância ou o nome, apenas mudando o default ou passando um valor personalizado. Falando nisso: como passamos valores se não quisermos usar o default? Existem algumas formas: usando o parâmetro `-var` no comando apply/plan (ex: `terraform apply -var=\"instance_type=t3.small\"` para sobrescrever), ou então definindo um arquivo `.tfvars` com valores. Mas se não fizermos nada, os defaults definidos serão usados. Por enquanto, vamos seguir com os defaults.”\n===encerramento da cena===\n---\n## CENA 7 – OUTPUTS: EXPONDO INFORMAÇÕES\n====INT. TELA DO COMPUTADOR - DIA====\nO instrutor agora volta ao editor de código e cria um arquivo `outputs.tf`.\n  \n**INSTRUTOR:**\nAgora que usamos variáveis de entrada para flexibilizar _o que entra_ no Terraform, vamos falar sobre os **Outputs**, que determinam _o que sai_. Outputs são valores que o Terraform pode nos mostrar após aplicar as mudanças, extraídos do estado final dos recursos. Isso é útil para obter IDs gerados, endereços IP, URLs, qualquer informação que nossos recursos possuam e que queremos guardar ou usar posteriormente.”\n\n**INSTRUTOR:**\nVamos supor que queiramos saber o endereço IP público da instância que criamos, assim que ela é provisionada. Podemos definir um output para isso.”\n\nNo arquivo outputs.tf, o instrutor digita:\n\n```hcl\noutput \"instance_public_ip\" {\n  description = \"Endereço IP público da instância EC2\"\n  value       = aws_instance.meu_servidor.public_ip\n}\n```\n\n**INSTRUTOR:**\nAqui definimos um output chamado `instance_public_ip`. A propriedade `value` faz referência ao recurso que criamos (`aws_instance.meu_servidor`) e pega o atributo `public_ip` dele. O Terraform sabe quais atributos estão disponíveis para cada tipo de recurso – no caso de instâncias EC2, `public_ip` é preenchido após a criação, se a instância tiver um IP público atribuído.”\n\n**INSTRUTOR:**\nTambém colocamos uma descrição para documentar o output. Podemos ter vários outputs, para qualquer informação que julgarmos útil. Vamos incluir outro exemplo simples: o ID da instância.”\n\nAdiciona outro bloco de output:\n\n```hcl\noutput \"instance_id\" {\n  description = \"ID da instância EC2 criada\"\n  value       = aws_instance.meu_servidor.id\n}\n```\n\n**INSTRUTOR:**\nPronto. Definimos dois outputs: o IP público e o ID da instância. Agora, quando aplicarmos nossas configurações, o Terraform vai exibir esses valores para nós.”\n===encerramento da cena===\n---\n## CENA 8 – VISUALIZANDO OUTPUTS\n====INT. TELA DO COMPUTADOR - DIA====\nNo terminal, o instrutor executa novamente o apply para captar os outputs.\n  \n**INSTRUTOR:**\nCom outputs definidos, vamos aplicar novamente as configurações. Desta vez, esperamos que ao final do `terraform apply`, o Terraform imprima os outputs configurados.”\n\nExecuta `terraform apply`. Após completar (provavelmente sem mudanças de infraestrutura, já que a instância já existe com mesmos parâmetros), o terminal apresenta algo como:\n\n\n```\nApply complete! Resources: 0 added, 0 changed, 0 destroyed.\n\nOutputs:\n\ninstance_id = \"i-0abc123def456\"\ninstance_public_ip = \"203.0.113.42\"\n```\n\n**INSTRUTOR:**\nVejam só, após a mensagem de sucesso do apply, temos a seção **Outputs** listando nossos outputs pelo nome. O Terraform puxou automaticamente o ID da instância e o IP público e exibiu para a gente. Isso é extremamente útil. Você pode copiar esses valores, usar em scripts, ou apenas verificar se tudo está conforme esperado (por exemplo, conferir se o IP público corresponde à instância criada).”\n\n**INSTRUTOR:**\nAlém disso, podemos obter outputs a qualquer momento depois do apply usando o comando `terraform output`. Se quisermos somente o IP, poderíamos rodar `terraform output instance_public_ip`. Há também a opção `-raw` para pegar o valor sem formatação extra. Isso ajuda quando se quer integrar com outra ferramenta ou script.”\n===encerramento da cena===\n---\n## CENA 9 – CONCLUSÃO E BOAS PRÁTICAS\n====INT. TELA DO COMPUTADOR - DIA====\nO instrutor fecha o editor, mostrando agora os três arquivos (main.tf, variables.tf, outputs.tf) lado a lado, enfatizando a organização.\n  \n**INSTRUTOR:**\nNosso código ficou mais organizado e flexível. Agora temos variáveis definidas claramente e outputs úteis. Com isso, podemos reutilizar essa configuração facilmente: se precisarmos lançar instâncias em outra região ou mudar algum detalhe, ajustamos as variáveis ao invés de mexer no código fundamental. Também ficou mais fácil compartilhar informações – por exemplo, em um cenário de múltiplos módulos Terraform, outputs de um módulo podem ser usados como inputs em outro. Mas isso é assunto para depois.”\n\n**INSTRUTOR:**\nResumo do que aprendemos: **Variáveis** permitem parametrizar configurações (melhorando manutenção e reutilização), e **Outputs** permitem expor dados da infraestrutura criada (facilitando consultas e integrações). Recomenda-se sempre documentar bem as variáveis (com description) e usar nomes de output claros, para que outros ou você mesmo no futuro entendam o propósito de cada um.”\n\n**INSTRUTOR:**\nNo próximo tutorial, exploraremos o Terraform State – o arquivo de estado do Terraform, que é peça-chave para entender como o Terraform rastreia os recursos que criou. Até lá, se quiser praticar, tente adicionar mais variáveis (por exemplo, a região como variável) ou outputs adicionais (como o tipo da instância ou outra propriedade) e veja os resultados. Nos vemos em breve!”\n\nEncerra com a imagem de um código Terraform mais limpo e genérico, simbolizando o avanço conquistado neste episódio.\n===fade out==="
  },
  {
    "id": "e3130fd4-3f70-4a01-97f7-f2a25a4a6b5c",
    "titulo": "Terraform State",
    "nivel": "iniciante",
    "ferramenta": "Terraform",
    "conteudo": "## CENA 1 – RECAPITULAÇÃO\nVinheta “Anteriormente” mostra: variáveis sendo usadas no código e outputs exibidos no terminal.\n\n**INSTRUTOR:**\nJá configuramos nosso ambiente, criamos recursos com Terraform e tornamos nosso código mais robusto com variáveis e outputs. Agora você deve estar se perguntando: como o Terraform sabe o que já foi criado? Como ele acompanha mudanças na infraestrutura ao longo do tempo? A resposta está no **Terraform State**. No episódio de hoje, vamos dissecar o arquivo de estado do Terraform e aprender a gerenciá-lo.\n===encerramento da cena===\n---\n## CENA 2 – ABERTURA\n====INT. TELA DO COMPUTADOR - DIA====\nAbre em uma visualização conceitual: um ícone de arquivo (representando o state) conectando uma configuração Terraform a recursos em nuvem desenhados. Setas indicam a relação entre código, state e infraestrutura real.\n \n**INSTRUTOR:**\nBem-vindo ao Tutorial 4! Hoje vamos falar sobre o **Terraform State**, o estado do Terraform. Sempre que aplicamos uma configuração, o Terraform mantém um registro em um arquivo especial, geralmente chamado `terraform.tfstate`. Esse arquivo é o coração do funcionamento do Terraform – é ali que ele guarda detalhes de todos os recursos provisionados, para saber o que existe, acompanhar atributos e orquestrar as próximas mudanças corretamente.\n\n**INSTRUTOR:**\nEntender o state é crucial. Vamos ver como o Terraform usa esse arquivo de estado, quais cuidados devemos ter com ele e como podemos até armazená-lo remotamente para colaboração ou segurança. Em outras palavras, após hoje, você saberá o que está acontecendo nos bastidores do Terraform.\n===encerramento da cena===\n---\n## CENA 3 – O QUE É O STATE?\n====INT. TELA DO COMPUTADOR - DIA====\nO instrutor aparece ao lado de uma representação do arquivo `terraform.tfstate` (um ícone de documento). Dentro do ícone, rótulos de recursos e IDs são visíveis de forma esquemática.\n\n**INSTRUTOR:**\nVamos começar do básico: **o que exatamente é o Terraform state?** Simplificando, é um arquivo JSON que o Terraform usa para mapear sua configuração declarativa aos objetos reais criados na nuvem. Quando você rodou `terraform apply` nos tutoriais anteriores, o Terraform não apenas criou a instância EC2, mas também registrou no state o ID dessa instância, a região, e outros atributos retornados pela AWS.\n\n**INSTRUTOR:**\nPor quê? Porque da próxima vez que executarmos um `plan` ou `apply`, o Terraform lerá o state para saber o que _já existe_ e, assim, calcular o que precisa mudar. O state é a memória do Terraform. Sem o arquivo de state, o Terraform perderia o controle do que está gerenciando – ele não saberia que aquela instância EC2 já foi criada por ele, por exemplo, e poderia tentar recriá-la ou acusar erro.\n===encerramento da cena===\n---\n## CENA 4 – EXPLORANDO O ARQUIVO DE STATE (LOCAL)## \n====INT. TELA DO COMPUTADOR - DIA====\nO instrutor abre o explorador de arquivos do sistema, navegando até a pasta do projeto Terraform. Lá, um arquivo `terraform.tfstate` está presente.\n \n**INSTRUTOR:**\nSempre que você executa um `terraform apply`, um arquivo `terraform.tfstate` (e um backup `.tfstate.backup`) é gerado/atualizado no diretório do seu projeto. Vamos dar uma olhadinha (de forma segura) nesse arquivo para entender o que ele contém.\n\nAbre-se o arquivo de estado (provavelmente grande e em JSON) em modo somente leitura. O instrutor rola até encontrar a entrada do recurso.\n \n**INSTRUTOR:**\nVeja, o state é em formato JSON. Dentro dele há informações detalhadas. Vamos encontrar nosso recurso `aws_instance.meu_servidor`.\n\nDestaca trecho relevante:\n\n**INSTRUTOR:**\nAqui está: vemos o `\"aws_instance.meu_servidor\"` com todos os atributos registrados – ID da instância, AMI usada, tags, IP público, etc. Tudo o que o provedor AWS retornou após criar o recurso ficou salvo. É com base nisso que, se mudarmos algo no código (por exemplo, o tipo da instância), o Terraform consegue comparar o desejado (config .tf) com o atual (state) e planejar apenas a diferença (alterar a instância).\n\n**INSTRUTOR:**\nVale um conselho: **não edite manualmente o arquivo de state**. Alterações manuais podem corromper ou desincronizar o Terraform do mundo real. Trate-o como um arquivo de base de dados interna do Terraform. Se precisar mudar algo (por exemplo, remover um recurso do state sem destruí-lo na real, ou consertar um drift), o Terraform oferece comandos próprios, como `terraform state rm` ou `terraform import` – falaremos disso já já.\n===encerramento da cena===\n---\n## CENA 5 – GERENCIANDO O STATE\n====INT. TELA DO COMPUTADOR - DIA====\nO instrutor limpa a tela e lista algumas operações possíveis relativas ao state, com situações de exemplo.\n \n**INSTRUTOR:**\nO Terraform provê comandos para interagir com o state em casos especiais:\n\n**INSTRUTOR:**\n`terraform state list` – _lista_ todos os recursos atualmente registrados no state (útil para visualizar o que Terraform gerencia).\n\n**INSTRUTOR:**\n`terraform state show <recurso>` – mostra detalhes de um recurso específico do state (sem precisar abrir o arquivo manualmente).\n\n**INSTRUTOR:**\n`terraform state rm <recurso>` – remove um recurso do state **sem** destruir o recurso real. (Por exemplo, se você quer que o Terraform “esqueça” determinado objeto, talvez para entregá-lo a outro processo).\n\n**INSTRUTOR:**\n`terraform import <recurso> <id>` – adiciona ao state um recurso **já existente** que não foi criado pelo Terraform originalmente, mapeando-o a uma configuração. (Ex: você criou uma instância manualmente e agora quer que o Terraform passe a gerenciá-la).\n\n**INSTRUTOR:**\n`terraform refresh` (nota: a partir da versão 0.15 esse comando foi substituído pelo `terraform apply -refresh-only` ou ações no plan) – atualizava o state consultando a infraestrutura real, útil para sincronizar mudanças ocorridas fora do Terraform.\n\n**INSTRUTOR:**\nEsses comandos são avançados e devem ser usados com cautela. A lição principal é: o state deve refletir a realidade. Se recursos são criados fora do Terraform, ele não saberá a menos que você importe. Se algo é destruído fora do Terraform, o state ficará com referência órfã e o próximo plan vai tentar criar de novo (ou pode falhar ao não encontrar o recurso). Por isso, procure realizar mudanças na infraestrutura sempre via Terraform, ou atualize o state adequadamente quando for misturar.\n===encerramento da cena===\n---\n## CENA 6 – STATE REMOTO\n====INT. TELA DO COMPUTADOR - DIA====\nO instrutor agora mostra dois desenvolvedores diferentes tentando usar Terraform no mesmo projeto, destacando um potencial problema se ambos usam state local.\n\n**INSTRUTOR:**\nVamos pensar em colaboração: até agora usamos o state local (arquivo em nossa máquina). Isso funciona bem em ambiente de aprendizado ou para projetos pessoais. Mas em um time, ou mesmo para manter histórico e backups, é comum optarmos por um **State Remoto**. O Terraform permite armazenar o state em locais como um bucket S3 na AWS, um blob storage no Azure, ou em serviços como Terraform Cloud, etc.\n\nMostra um diagrama: vários desenvolvedores -> bucket S3 -> nuvem, simbolizando state compartilhado.\n \n**INSTRUTOR:**\nAo usar um backend de estado remoto, todos que trabalham na mesma configuração acessam o mesmo arquivo de state centralizado. Isso evita condições de corrida e diferenças de state local. Além disso, backends como S3 com DynamoDB (para lock) ou Terraform Cloud fornecem _locking_, isto é, impedem que dois applies rodem ao mesmo tempo no mesmo state – o que poderia causar conflitos.\n\n**INSTRUTOR:**\nPor exemplo, para configurar um backend remoto no nosso projeto AWS, poderíamos adicionar no início do código Terraform um bloco backend apontando para um bucket S3. Ficaria algo como:”\n\nO instrutor demonstra um trecho de configuração de backend no código:\n\n```hcl\nterraform {\n  backend \"s3\" {\n    bucket = \"meu-bucket-terraform-state\"\n    key    = \"projeto/terraform.tfstate\"\n    region = \"us-east-1\"\n    dynamodb_table = \"terraform-lock\"\n    encrypt = true\n  }\n}\n```\n\n**INSTRUTOR:**\nEssa configuração (colocada em um arquivo terraform.tf ou mesmo no main.tf) diz ao Terraform para usar um **backend do tipo S3**. Informamos o nome do bucket, uma chave (caminho/nome do arquivo dentro do bucket), a região e, importante, um DynamoDB table para lock. O Terraform então, no `terraform init`, configurará o state remoto. Caso já exista um state local com recursos, ele até solicitará migração para o S3 automaticamente.\n\n**INSTRUTOR:**\nNo Azure, seria semelhante usando `backend \"azurerm\"` indicando a conta de armazenamento, container, etc. O princípio é o mesmo. Backends remotos garantem que o state esteja seguro (por exemplo, no bucket pode ser versionado e protegido) e compartilhado entre equipes. Em contrapartida, aumentam a complexidade inicial (é preciso já ter o bucket ou recurso para guardar o state). Mas em ambientes profissionais, vale muito a pena.\n===encerramento da cena===\n---\n## CENA 7 – CUIDADOS COM O STATE\n====INT. TELA DO COMPUTADOR - DIA====\nO instrutor aparece em um cenário de alerta moderado, indicando práticas seguras.\n  \n**INSTRUTOR:**\nDicas importantes ao lidar com state:\n\n**INSTRUTOR:**\n**Não commite o arquivo de state em controle de versão** (git, etc). Ele contém informações potencialmente sensíveis (passwords de banco, IPs, etc) e muda a cada apply, causando conflitos. Prefira o backend remoto ou ignore o tfstate no .gitignore.\n\n**INSTRUTOR:**\nFaça backup do state ou use backend remoto para não perdê-lo. Se perder o state local e não tiver backups, o Terraform ‘esquece’ seus recursos – recuperá-los exigirá import manual, o que pode ser trabalhoso.\n\n**INSTRUTOR:**\nAo trabalhar em equipe no mesmo state, coordene as mudanças (usando locking ou um fluxo de CI/CD) para evitar que duas pessoas alterem o state ao mesmo tempo.\n\n**INSTRUTOR:**\nMantenha o state **confidencial** – apenas pessoas com necessidade devem acessá-lo. Por exemplo, usar um bucket privado e com acesso restrito, já que ele revela toda sua infraestrutura.\n===encerramento da cena===\n---\n## CENA 8 – ENCERRAMENTO\n====INT. TELA DO COMPUTADOR - DIA====\nRetorna ao diagrama do state conectado entre config e infra, agora com a compreensão completa. O instrutor se prepara para concluir.\n\n**INSTRUTOR:**\nHoje exploramos o Terraform State, essa peça fundamental do quebra-cabeça. Agora você sabe que o Terraform guarda um mapa de tudo o que criou em um arquivo de estado e que esse arquivo permite ao Terraform orquestrar mudanças incrementais de forma inteligente. Aprendemos também sobre armazenar o state remotamente para colaboração e segurança.\n\n**INSTRUTOR:**\nNo próximo tutorial, partiremos para algo diferente: os **Provisioners** – como executar scripts ou comandos durante a criação dos recursos para realizar configurações adicionais. Até lá, reflita sobre o state: abra seu terraform.tfstate (somente leitura) para ver o que ele contém ou experimente usar o `terraform state list` para ver seus recursos registrados. Essa familiaridade ajuda a diagnosticar problemas no futuro. Nos vemos no próximo episódio!\n\nFade out com a imagem do arquivo terraform.tfstate destacada, finalizando o Tutorial 4.\n===fade out==="
  },
  {
    "id": "1bf96287-26cd-4fc0-aedd-cee7a036b4c0",
    "titulo": "Provisioners",
    "nivel": "iniciante",
    "ferramenta": "Terraform",
    "conteudo": "## CENA 1 – RECAPITULAÇÃO\nImagens de flashback: o arquivo de state e um diagrama de state remoto, enfatizando o conteúdo do tutorial anterior.\n\n**INSTRUTOR:**\nNo último tutorial, mergulhamos no Terraform State e entendemos como o Terraform rastreia nossos recursos. Com isso, cobrimos o núcleo da infraestrutura como código. Agora vamos além da declaração de infraestrutura: veremos como executar configurações pós-provisionamento nos recursos criados usando os **Provisioners**.\n===encerramento da cena===\n---\n## CENA 2 – ABERTURA \nAbre em uma cena ilustrativa: uma instância de servidor acaba de ser criada (representada por um ícone de servidor), e logo após, um script é executado dentro dela (ícone de engrenagem ou terminal sobreposto ao servidor). Isso representa a ideia de provisionamento pós-criação.\n\n**INSTRUTOR:**\nBem-vindo ao Tutorial 5! Hoje trataremos dos **Provisioners** no Terraform. Imagine que você criou uma máquina virtual pela configuração do Terraform, mas quer instalar um software ou rodar um comando nela assim que estiver pronta. É aí que entram os provisioners: eles permitem conectar passos de configuração (scripts, comandos) durante a criação ou remoção de recursos.\n\n**INSTRUTOR:**\nOs provisioners funcionam como um _passo extra_ além da pura infraestrutura, e precisam ser usados com cuidado. Vamos mostrar como utilizá-los, tipos diferentes (local-exec, remote-exec, etc.) e discutir quando são úteis. Hora de automatizar aquelas tarefas pós-criação que muitas vezes fazemos manualmente!\n===encerramento da cena===\n---\n## CENA 3 – O QUE SÃO PROVISIONERS? \nInstrutor ao lado de um diagrama com um recurso Terraform e uma caixinha de script associada.\n\n**INSTRUTOR:**\nProvisioners são blocos especiais que podemos anexar aos recursos no Terraform. Quando o Terraform cria ou destrói o recurso, ele pode executar as ações definidas no provisioner. Existem basicamente dois contextos: _local_ e _remoto_. O provisioner **local-exec** executa um comando no **host local** (onde o Terraform está rodando). Já o **remote-exec** executa comandos dentro do **recurso remoto** (por exemplo, dentro da VM criada). Também há um provisioner de **file**, que copia arquivos do local para o recurso remoto.\n\n**INSTRUTOR:**\nPense assim: o Terraform por si provisiona infraestrutura bruta. Os provisioners permitem, por exemplo, instalar dependências, configurar arquivos ou iniciar serviços após a criação. No entanto, enfatizo: provisioners devem ser o último recurso; se algo pode ser feito via recursos nativos (por exemplo, usar terraform para iniciar um serviço gerenciado), prefira fazê-lo nativamente. Provisioners são melhores para aquelas configurações que realmente precisam rodar dentro do sistema provisionado ou para chamadas externas que o Terraform em si não cobre.\n===encerramento da cena===\n---\n## CENA 4 – EXEMPLO DE LOCAL-EXEC \nVolta ao código no editor. O instrutor mostra como adicionar um provisioner local-exec.\n\n**INSTRUTOR:**\nVamos começar com um exemplo simples: um **local-exec**. Suponha que, após criar a instância EC2, queremos rodar um comando na nossa máquina local para registrar essa informação em um log ou notificar alguém. Podemos adicionar um provisioner local-exec no recurso.\n\nNo `aws_instance.meu_servidor` dentro do main.tf, o instrutor adiciona:\n\n```hcl\nprovisioner \"local-exec\" {\n  command = \"echo Instância ${self.id} criada na região ${self.region} > instancias.log\"\n}\n```\n\n**INSTRUTOR:**\nAqui adicionamos um provisioner do tipo local-exec. O comando especificado é executado localmente, usando informações do recurso via variáveis especiais (`${self.id}` referencia o ID da instância criada, `${self.region}` a região). Nesse exemplo, estamos simplesmente fazendo um `echo` dessas informações para um arquivo `instancias.log` no nosso computador local. Isso aconteceria após a criação bem-sucedida da instância.\n\n**INSTRUTOR:**\n`self` refere-se ao próprio recurso ao qual o provisioner está anexado. Assim, podemos acessar atributos dele. Esse comando rodaria quando o Terraform criar a instância. Se quiséssemos que algo rodasse ao destruir, poderíamos usar `when = destroy` no provisioner, mas o padrão (sem especificar) é rodar na criação.\n===encerramento da cena===\n---\n## CENA 5 – EXEMPLO DE REMOTE-EXEC \nAgora o instrutor explica o remote-exec e mostra como usá-lo. A cena ilustra uma conexão SSH sendo estabelecida.\n\n**INSTRUTOR:**\nO **remote-exec** é um pouco mais complexo, pois envolve executar comandos dentro da instância criada. Para isso, o Terraform precisa conseguir se conectar ao recurso – normalmente via SSH (para Linux) ou WinRM (para Windows). Vamos presumir que nossa instância EC2 é Linux e que já especificamos ou conhecemos a chave SSH para acessar. Lembra que lá no início definimos a instância com uma key pair? Precisamos usar essa chave aqui.\n\n**INSTRUTOR:**\nAntes de adicionar o remote-exec, precisamos garantir dois pontos: (1) a instância permite conexão SSH – ou seja, grupo de segurança com porta 22 liberada para nosso IP, e (2) temos a chave privada correspondente à key pair usada. Vamos supor que nossa instância está com a porta 22 aberta (poderíamos ter definido um `aws_security_group` para isso, mas não cobrimos esse recurso aqui – vamos assumir que está configurado) e a key pair nomeada “MinhaKey” está em mãos. No Terraform, definimos a conexão assim:\n\nNo mesmo recurso, adiciona um provisioner remote-exec:\n\n```hcl\nprovisioner \"remote-exec\" {\n  inline = [\n    \"sudo apt-get update -y\",\n    \"sudo apt-get install -y apache2\"\n  ]\n  connection {\n    type        = \"ssh\"\n    user        = \"ubuntu\"                 // usuário padrão (depende da AMI, aqui supondo Ubuntu)\n    private_key = file(\"~/.ssh/MinhaKey.pem\")\n    host        = self.public_ip\n  }\n}\n```\n\n**INSTRUTOR:**\nVamos dissecar isso: definimos um provisioner `remote-exec` com dois comandos na forma _inline_. Ou seja, ele vai executar sequência de comandos dentro da instância: primeiro um update do apt, depois instala o Apache2. Isso é só um exemplo comum de configurar um servidor web básico após subir a VM. Poderíamos executar qualquer comando ou chamar um script presente na máquina.\n\n**INSTRUTOR:**\nNa seção `connection`, especificamos _como_ se conectar: via SSH, usando o usuário correto (no caso de uma AMI Ubuntu, o user costuma ser “ubuntu”; se fosse Amazon Linux, seria “ec2-user”, por exemplo). Passamos a chave privada usando a função Terraform `file()` para ler o arquivo local da chave (que deve ter permissões adequadas no sistema). E indicamos que o host é o `self.public_ip` – ou seja, o IP da instância EC2 recém-criada. Assim, o Terraform vai tentar SSH nessa máquina para rodar os comandos informados.\n\n**INSTRUTOR:**\nSe tudo está configurado (chave certa, instância acessível), esse provisioner remote-exec irá instalar o Apache automaticamente assim que a máquina estiver pronta. Você pode imaginar o poder: podemos automatizar configurações sem ter que manualmente acessar a máquina depois. Isso aproxima Terraform de ferramentas de configuração, embora repito: se sua organização usa algo como Ansible, Chef, etc, eles prefeririam usar essas ferramentas para pós-provisionamento. Ainda assim, para pequenos casos ou automações rápidas, provisioners resolvem bem.\n===encerramento da cena===\n---\n## CENA 6 – EXECUÇÃO E COMPORTAMENTO\n\nO instrutor fala sobre como isso se comporta durante o apply.\n\n**INSTRUTOR:**\nQuando usamos provisioners, a execução do `terraform apply` muda um pouquinho: após criar o recurso, o Terraform executa os provisioners associados. Se um provisioner falha (retorna erro), por padrão o Terraform marca o recurso como _erro_ também. Ou seja, se o script dentro do remote-exec falhar, o Terraform vai considerar toda a criação do recurso como falha e possivelmente destruir o recurso, dependendo da situação. Isso é importante: um comando mal sucedido pode derrubar seu recurso se não tratado.\n\n**INSTRUTOR:**\nExiste a opção `on_failure` no provisioner para controlar isso. Por exemplo, `on_failure = continue` faria o Terraform prosseguir mesmo se o provisioner falhar (marcando o erro mas não destruindo o recurso). Use isso com cuidado – às vezes é melhor perceber o erro e corrigir do que ignorar. Mas em alguns casos de comandos não tão vitais, pode ser útil.\n\n**INSTRUTOR:**\nOutro ponto: provisioners rodam **depois** que o recurso é criado (ou antes de destruir, no caso de destroy). Se você tem múltiplos recursos dependentes, o Terraform cuida das dependências normalmente. Por exemplo, se um remote-exec depende que a instância esteja pronta, o Terraform já sabe disso intrinsecamente. Mas se você tivesse um provisioner que deve rodar só após múltiplos recursos estarem prontos, pode precisar modelar dependências via `depends_on` ou juntar num null_resource (um recurso artificial) com provisioner dependente de todos – mas aí já é mais avançado.\n===encerramento da cena===\n---\n## CENA 7 – PROVISIONERS COMO ÚLTIMO RECURSO\nInstrutor em tom de orientação de melhores práticas.\n \n**INSTRUTOR:**\nÉ importante mencionar: **Provisioners devem ser evitados quando possível**. A própria HashiCorp recomenda usá-los somente quando não houver outro jeito direto. Por quê? Porque provisioners fogem um pouco do modelo declarativo do Terraform, introduzindo passos imperativos que podem não ser totalmente reproduzíveis ou idempotentes. Por exemplo, se um provisioner instala um pacote, reexecutá-lo pode tentar instalar de novo algo já instalado – você precisa cuidar para que seus scripts sejam idempotentes ou usar condicionais se necessário.\n\n**INSTRUTOR:**\nAlém disso, quando o Terraform re-aplica configurações sem recriar o recurso, os provisioners geralmente não rodam de novo (exceto se o recurso for recriado). Ou seja, um provisioner remote-exec não vai rodar a cada apply, apenas quando aquele recurso é criado inicialmente ou destruído (no caso de provisioner de destroy). Isso significa que se você mudar os comandos do provisioner mas não força a recriação da instância, nada acontecerá na máquina já criada. Logo, provisioners não são um mecanismo de contínua configuração – eles são one-time quando da criação ou remoção.\n===encerramento da cena===\n---\n## CENA 8 – ENCERRAMENTO \nMostra-se a configuração final com provisioners integrados no código do recurso, destacando as partes relevantes.\n\n**INSTRUTOR:**\nRecapitulando: aprendemos a anexar provisioners para executar ações locais ou remotas durante a aplicação do Terraform. Vimos exemplos de local-exec (rodando comando no host local) e remote-exec (rodando dentro da instância em nuvem via SSH). Isso nos dá capacidade de, por exemplo, instalar pacotes em servidores recém-criados ou notificar sistemas externos sobre as mudanças.\n\n**INSTRUTOR:**\nUse provisioners com parcimônia e sempre teste bem os scripts para garantir que erros sejam tratados. Muitas vezes, para configurações complexas, considere usar ferramentas dedicadas ou as próprias configurações da nuvem (por exemplo, userdata em EC2 ou extensões de VM no Azure). Ainda assim, agora você tem mais essa ferramenta no seu arsenal Terraform quando precisar aquele grau a mais de automação.\n\n**INSTRUTOR:**\nNo próximo tutorial, vamos falar de **Módulos** – como estruturar e reutilizar nosso código Terraform de maneira elegante. Até lá, você pode praticar adicionando um provisioner local-exec simples que, por exemplo, faça um ping para verificar se a instância responde após criar, ou algo do tipo. Obrigado e até o próximo episódio!\n\nEncerra com a imagem de um servidor e um script, conectados por um raio simbolizando automação, consolidando o tema de provisioners.\n===fade out==="
  },
  {
    "id": "9c6de2ee-c55e-4def-858c-ccf7ccf17810",
    "titulo": "Módulos",
    "nivel": "iniciante",
    "ferramenta": "Terraform",
    "conteudo": "## CENA 1 – RECAPITULAÇÃO\nFlashback: trechos do código com provisioners e a explicação de remote vs local, do episódio anterior.\n\n**INSTRUTOR:**\nJá passamos por muita coisa: criamos recursos básicos, usamos variáveis e outputs, entendemos o state e até executamos scripts com provisioners. Conforme nossa infraestrutura codificada cresce, podemos notar partes repetidas ou a necessidade de organizar melhor a configuração. É aí que entram os **Módulos** do Terraform, nosso assunto de hoje.\n===encerramento da cena===\n---\n## CENA 2 – ABERTURA\nCena inicial mostra um grande arquivo Terraform com múltiplos recursos, então a câmera “segmenta” esse arquivo em pedaços menores organizados, representando a modularização. Também mostra um caixinha representando um módulo reutilizável.\n\n**INSTRUTOR:**\nBem-vindo ao Tutorial 6! Hoje vamos falar de **Módulos no Terraform**. Módulos permitem **reutilizar** e **organizar** configurações, evitando duplicação de código e facilitando a manutenção. Pense nos módulos como funções em programação: você escreve uma vez um conjunto de instruções (recursos Terraform, no caso) e depois pode reutilizar essa ‘função’ quantas vezes quiser, possivelmente com parâmetros diferentes.\n\n**INSTRUTOR:**\nNesta aula, vamos criar nosso próprio módulo simples e também mostrar como usar módulos públicos disponíveis. Você vai aprender a estruturar o código do módulo, passar variáveis para ele e obter outputs dele. Isso leva seu código Terraform para um nível mais profissional, permitindo composição de infraestrutura de forma limpa.\n===encerramento da cena===\n---\n## CENA 3 – O CONCEITO DE MÓDULO\nInstrutor ao lado de blocos representando módulos conectáveis.\n\n**INSTRUTOR:**\nPrimeiro, o conceito: **todo diretório com arquivos .tf pode ser um módulo**. Na verdade, até mesmo a configuração principal que temos usado é o _módulo raiz_ (root module). Quando incluímos um bloco `module` em um Terraform, estamos dizendo ao Terraform para carregar outro conjunto de configurações de outro diretório ou fonte e integrá-lo. Esse módulo pode receber variáveis (entradas) e fornecer outputs (saídas), parecido com funções de programação com parâmetros e retorno.\n\n**INSTRUTOR:**\nPor exemplo, se você precisa criar várias instâncias EC2 similares, poderia criar um módulo “instancia_ec2” que configura uma instância com as melhores práticas (variáveis para AMI, tipo, etc), e então chamá-lo múltiplas vezes ao invés de repetir o código. Ou usar um módulo pronto da comunidade, como um módulo de VPC que já cria sub-redes, roteadores etc, sem você reinventar a roda.\n===encerramento da cena===\n---\n## CENA 4 – CRIANDO UM MÓDULO LOCAL\nNo projeto, o instrutor cria uma pasta separada chamada `modules/instancia_basica`. Dentro, começa a criar arquivos.\n\n**INSTRUTOR:**\nVamos praticar criando um módulo local para nossas instâncias EC2. Vamos mover a lógica de criar uma instância para um módulo, tornando-o reutilizável. Primeiro, no nosso projeto, criarei um diretório chamado `modules/instancia_basica` (você pode escolher o nome que quiser para o módulo). Dentro dele, vou criar três arquivos usuais: `main.tf`, `variables.tf` e `outputs.tf` para o módulo.\n\nAbre-se o editor no contexto do módulo (modules/instancia_basica). O instrutor escreve em variables.tf do módulo:\n\n```hcl\nvariable \"instance_ami\" {\n  type        = string\n  description = \"AMI da instância\"\n}\n\nvariable \"instance_type\" {\n  type        = string\n  description = \"Tipo da instância\"\n  default     = \"t2.micro\"\n}\n\nvariable \"instance_name\" {\n  type        = string\n  description = \"Tag Name da instância\"\n  default     = \"ServidorModulo\"\n}\n```\n\n**INSTRUTOR:**\nDefinimos as variáveis que o módulo vai aceitar. Aqui nós colocamos `instance_ami` sem default (obrigando quem usar o módulo a especificar qual AMI usar), e demos defaults para `instance_type` e `instance_name` para conveniência.\n\nAgora no main.tf do módulo:\n\n```hcl\nresource \"aws_instance\" \"vm\" {\n  ami           = var.instance_ami\n  instance_type = var.instance_type\n\n  tags = {\n    Name = var.instance_name\n  }\n}\n```\n\n**INSTRUTOR:**\nNo `main.tf` do módulo, criamos o recurso `aws_instance` praticamente igual fazíamos antes, mas usando os `var.` das variáveis do módulo. Repare que dei um nome de recurso `vm` aqui (dentro do módulo, esse nome só precisa ser único naquele módulo). Esse recurso utilizará os valores passados quando o módulo for chamado.\n\nAgora outputs.tf do módulo:\n\n```hcl\noutput \"instance_id\" {\n  description = \"ID da instância criada pelo módulo\"\n  value       = aws_instance.vm.id\n}\n\noutput \"instance_public_ip\" {\n  description = \"IP público da instância criada\"\n  value       = aws_instance.vm.public_ip\n}\n```\n\n**INSTRUTOR:**\nDefinimos outputs no módulo para expor o ID e IP da instância criada. Assim, quando usarmos o módulo, podemos capturar essas informações se precisarmos, ou simplesmente tê-las impressas ao final.\n===encerramento da cena===\n---\n## CENA 5 – USANDO O MÓDULO\nVolta ao arquivo main.tf do módulo raiz (que antes tinha o recurso definindo a instância). O instrutor vai modificar o root module para usar o child module.\n\n**INSTRUTOR:**\nAgora que nosso módulo local está pronto, vamos usá-lo no nosso módulo raiz (o projeto principal). Em vez de termos definido a instância diretamente no root, vamos chamar o módulo para criar a instância.\n\nNo main.tf do root (ou pode criar uma separação, mas pode ser no próprio main.tf), instrutor escreve:\n\n```hcl\nmodule \"minha_instancia\" {\n  source = \"./modules/instancia_basica\"\n\n  instance_ami   = \"ami-0c55b159cbfafe1f0\"\n  instance_type  = \"t2.micro\"\n  instance_name  = \"ServidorViaModulo\"\n}\n```\n\n**INSTRUTOR:**\nAqui usamos o bloco `module`. Damos um nome (alias) a essa instância do módulo – no caso, `minha_instancia`. A propriedade `source` aponta para o caminho do módulo local (`./modules/instancia_basica`). Se fosse um módulo remoto da registry ou git, o source seria diferente (vamos falar já já). Em seguida, passamos os valores para as variáveis que o módulo espera: AMI, tipo e nome. Coloquei valores similares aos anteriores, mudando o nome para identificar que veio do módulo.\n\n**INSTRUTOR:**\nQuando rodarmos Terraform, ele vai entrar na pasta do módulo, carregar aquela config e criar os recursos definidos lá. Para o Terraform, isso é como se fizesse parte do mesmo conjunto geral, apenas isolado logicamente. Uma vantagem é que podemos reutilizar esse módulo facilmente: se quisermos outra instância, poderíamos adicionar outro bloco module com outro alias e outros valores. Vamos exemplificar adicionando mais uma instância via módulo, só que de outro tipo.\n\nAdiciona outro module call:\n\n```hcl\nmodule \"minha_instancia2\" {\n  source = \"./modules/instancia_basica\"\n\n  instance_ami   = \"ami-0c55b159cbfafe1f0\"\n  instance_type  = \"t2.small\"\n  instance_name  = \"OutroServidor\"\n}\n```\n\n**INSTRUTOR:**\nAgora chamamos o mesmo módulo `instancia_basica` novamente, com um alias diferente `minha_instancia2`. Alteramos o `instance_type` para `t2.small` só para diferenciar. Isso criará uma segunda instância EC2, sem termos que duplicar todo o bloco de recurso manualmente – reusamos o código do módulo.\n===encerramento da cena===\n---\n## CENA 6 – TESTANDO O MÓDULO\nExecução do plan/apply com módulos.\n\n**INSTRUTOR:**\nVamos rodar um `terraform init` primeiro, porque agora introduzimos um módulo. O Terraform vai perceber a configuração do módulo e preparar tudo (no caso de módulo local, é simples, mas se fosse remoto, ele baixaria).\n\nExecuta `terraform init` – a saída mostra que módulos foram encontrados e carregados.\n\n**INSTRUTOR:**\nAgora um `terraform plan`.\n\nO plan deve mostrar a criação de 2 aws_instances via módulos.\n\n**INSTRUTOR:**\nNo plano, repare que o Terraform lista recursos dentro dos módulos: algo como `module.minha_instancia.aws_instance.vm` e `module.minha_instancia2.aws_instance.vm` serão criados. Isso indica que dentro de cada chamada do módulo, o recurso `vm` definido no módulo será instanciado, resultando em duas instâncias reais com configurações possivelmente diferentes.\n\n**INSTRUTOR:**\nTudo certo, vamos aplicar:\n\nExecuta `terraform apply` e confirma.\n\n**INSTRUTOR:**\nO Terraform agora cria as duas instâncias via módulo. Se olharmos a saída, também veremos outputs. Mas aqui um detalhe: definimos outputs dentro do módulo, mas eles só aparecem na saída geral se forem explicitamente expostos no root, a menos que a gente imprima via `terraform output`. Como usamos módulos locais sem declarar outputs no root, o Terraform não listará os outputs do módulo automaticamente ao final. Poderíamos, no root module, criar outputs que referenciam `module.minha_instancia.instance_id`, por exemplo, para repassar para fora. Contudo, não é obrigatório se não precisarmos. Podemos diretamente inspecionar com `terraform output` ou pelo state.\n\n**INSTRUTOR:**\nO importante é que nossas duas instâncias foram criadas com um único módulo reutilizável. Se quiséssemos atualizar algo sobre como criamos instâncias (digamos adicionar um security group), faríamos essa mudança dentro do módulo `instancia_basica`, e todas as instâncias geradas por ele poderiam ser atualizadas de uma vez mantendo consistência. Isso mostra o poder de centralizar lógica em módulos.\n===encerramento da cena===\n---\n## CENA 7 – MÓDULOS PÚBLICOS E REGISTRY\nInstrutor navega até o Terraform Registry em um navegador.\n\n**INSTRUTOR:**\nAlém de criar nossos próprios módulos, podemos **usar módulos públicos** disponíveis no Terraform Registry ou outros repositórios. O Terraform Registry (registry.terraform.io) contém módulos oficiais e da comunidade para diversas infraestruturas. Por exemplo, módulos para criar VPCs completas na AWS, ou configurar instâncias com autoscaling, etc. Eles já encapsulam as melhores práticas e configurações típicas.\n\nMostra a página de um módulo, por exemplo “terraform-aws-modules/vpc/aws”.\n\n**INSTRUTOR:**\nPara usar um módulo do registry, a sintaxe do `source` é algo como `terraform-aws-modules/vpc/aws` e geralmente adicionamos a versão: `?ref=versao` ou usando `version =`. Vamos supor que queremos usar um módulo de VPC ao invés de escrever do zero. Poderíamos fazer:\n\nExemplo breve sem realmente aplicar, apenas explicativo:\n\n```hcl\nmodule \"vpc\" {\n  source  = \"terraform-aws-modules/vpc/aws\"\n  version = \"3.5.0\"\n\n  name    = \"minha-vpc\"\n  cidr    = \"10.0.0.0/16\"\n  azs     = [\"us-east-1a\", \"us-east-1b\"]\n  subnets = [\"public\", \"private\"]\n  # ... e outras variáveis exigidas pelo módulo de VPC ...\n}\n```\n\n**INSTRUTOR:**\nEsse exemplo hipotético chamaria um módulo público de VPC (versão 3.5.0). Passamos as variáveis necessárias como nome, range de rede, zonas de disponibilidade e tipos de sub-rede. Em seguida, rodar `terraform init` baixaria automaticamente o módulo do registry. Isso economiza tempo enorme, pois não precisamos escrever todos os recursos de VPC manualmente – o módulo já o faz. Apenas adaptamos as entradas ao nosso contexto.\n\n**INSTRUTOR:**\nExistem módulos para muitas coisas – armazenamento, redes, máquinas, Kubernetes, etc. Sempre verifique a confiabilidade do módulo (quem mantém, número de downloads, etc) e entenda as variáveis e outputs que ele fornece. É comum complementar infra com módulos consagrados.\n===encerramento da cena===\n---\n## CENA 8 – ESTRUTURANDO PROJETOS COM MÓDULOS\nO instrutor dá dicas de organização.\n\n**INSTRUTOR:**\nAo usar módulos, seu projeto pode ficar organizado assim: um módulo raiz que orquestra recursos de alto nível e vários submódulos para componentes específicos (rede, instâncias, banco de dados, etc). Talvez até módulos aninhados (um módulo usando outro módulo internamente, se fizer sentido). Essa estrutura modular ajuda times a dividir trabalho e encapsular complexidade.\n\n**INSTRUTOR:**\nSempre documente as variáveis e outputs dos seus módulos, para que quem for usá-los (pode ser você mesmo depois de um tempo) saiba o que fornecer e o que esperar de retorno. Guarde seus módulos talvez em um repositório separado ou um registry interno, se forem genéricos para vários projetos.\n===encerramento da cena===\n---\n## CENA 9 – ENCERRAMENTO\nVisual final: representação de vários módulos conectados formando uma infraestrutura.\n\n**INSTRUTOR:**\nHoje aprendemos a criar e usar módulos no Terraform. Isso nos permite escrever menos código repetitivo e seguir o princípio DRY (Don’t Repeat Yourself). Refatoramos nossa configuração para utilizar um módulo local e mencionamos o uso de módulos da comunidade. Sua infraestrutura como código fica mais escalável e organizada assim.\n\n**INSTRUTOR:**\nNos próximos tutoriais, vamos ainda mais fundo em recursos avançados. No seguinte, falaremos sobre **Meta-argumentos** do Terraform, que oferecem controle extra sobre recursos (como loops e dependências explícitas). Até lá, experimente modularizar alguma parte do seu código Terraform ou explorar o Terraform Registry para ver o que está disponível. Nos vemos em breve no próximo episódio!\n\nTermina com uma imagem compondo várias engrenagens (módulos) que juntas formam a palavra Terraform, simbolizando a orquestração modular.\n===fade out==="
  },
  {
    "id": "f5557b9b-e89f-4cf1-978c-ca08593cb33d",
    "titulo": "Meta argumentos",
    "nivel": "iniciante",
    "ferramenta": "Terraform",
    "conteudo": "## CENA 1 – RECAPITULAÇÃO\nImagens rápidas da estrutura de módulos criada anteriormente, com múltiplas instâncias via módulo.\n\n**INSTRUTOR:**\nNo último tutorial, reorganizamos nosso código usando módulos, o que facilitou a reutilização de componentes de infraestrutura. Agora, vamos explorar alguns recursos avançados da sintaxe do Terraform que nos dão ainda mais controle e flexibilidade ao definir recursos: os **Meta-argumentos**. Esses pequenos poderosos recursos permitem criar vários recursos com facilidade, controlar dependências e personalizar o comportamento da criação e destruição.\n===encerramento da cena===\n---\n## CENA 2 – ABERTURA\nAbre mostrando um trecho de código Terraform com meta-argumentos destacados: `count`, `for_each`, e um `depends_on`. Talvez uma lista de servidores gerados dinamicamente esteja visível.\n\n**INSTRUTOR:**\nBem-vindo ao Tutorial 7! Hoje vamos dissecar os **Meta-argumentos do Terraform**. Meta-argumentos são argumentos especiais que podem ser usados dentro de blocos de recursos (e módulos) para influenciar a forma como o Terraform cria esses recursos. Os principais que veremos: `count`, `for_each`, `depends_on` e `lifecycle`. Com eles, podemos, por exemplo, **criar múltiplas instâncias de um recurso automaticamente**, iterar sobre listas ou mapas, forçar ordem de criação, e definir políticas de criação/remoção específicas.\n\n**INSTRUTOR:**\nEsses recursos elevam o nível do que podemos fazer sem escrever código repetitivo ou imperativo. Vamos conhecer cada um e ver exemplos práticos de uso.\n===encerramento da cena===\n---\n## CENA 3 – COUNT: MULTIPLICANDO RECURSOS\nInstrutor ao lado de um símbolo de multiplicação e vários recursos replicados.\n\n**INSTRUTOR:**\nPrimeiro, o meta-argumento **`count`**. Ele permite dizer ao Terraform para criar múltiplas cópias de um recurso com base em um número inteiro. Isso é útil quando você quer X instâncias iguais (ou quase iguais) sem ter que escrever X blocos manualmente. `count` espera um número. Se você colocar `count = 3` em um recurso, o Terraform criará **três instâncias** daquele recurso.\n\n**INSTRUTOR:**\nVamos aplicar na prática: e se quiséssemos criar 3 instâncias EC2 idênticas via Terraform sem módulo? A gente poderia usar count no recurso.\n\nNo editor, mostra um exemplo isolado:\n\n```hcl\nresource \"aws_instance\" \"servidor\" {\n  count         = 3\n  ami           = var.instance_ami\n  instance_type = var.instance_type\n\n  tags = {\n    Name = \"Servidor-${count.index}\"\n  }\n}\n```\n\n**INSTRUTOR:**\nNeste trecho, ao invés de antes termos um único aws_instance, definimos `count = 3`. Isso fará com que sejam criados `aws_instance.servidor[0]`, `[1]` e `[2]`. Repare que até usamos `count.index` dentro da tag Name para diferenciá-los: `count.index` é uma variável fornecida pelo Terraform dentro de recursos com count, indicando o índice atual (começando em 0). Assim, os Names seriam `Servidor-0`, `Servidor-1`, etc. Cada instância pode também usar ilde `count.index` para buscar, por exemplo, elementos de uma lista variável se quiséssemos dar configurações ligeiramente diferentes.\n\n**INSTRUTOR:**\nPodemos referenciar no restante do código esses recursos usando sintaxe de índice, por exemplo: `aws_instance.servidor[1].id` para o segundo. E se quisermos todos, alguns comandos ou construções suportam referenciar como um conjunto. Mas a ideia básica é: `count` permite criação em massa. Útil não só para instâncias, mas qualquer recurso repetitivo, como múltiplos discos, múltiplos endereços IP, etc.\n\n**INSTRUTOR:**\nUma dica: se `count` for 0, o Terraform não cria aquele recurso (pode ser usado para condicional simples – recurso opcional). Se aumentar ou diminuir `count`, o Terraform ajusta criando ou destruindo as cópias extras. Porém, cuidado: se você diminui de 3 para 2, por padrão ele destruirá a terceira. E se aumentar, ele cria novas no final da lista.\n\n**INSTRUTOR:**\nAh, importante: se a ordem ou número muda, os índices podem trocar de significado. Por exemplo, se você tinha 3 e remove a [1], passando para count=2, o [2] original pode passar a ser [1] agora. Isso pode levar a recriações indesejadas. Por isso, se a coleção de itens não é estável em tamanho, às vezes é melhor usar o `for_each` que veremos a seguir.\n===encerramento da cena===\n---\n## CENA 4 – FOR_EACH: ITERANDO SOBRE COLEÇÕES\nMostra a diferença: for_each com uma lista de nomes criando recs para cada nome, versus count.\n\n**INSTRUTOR:**\nO meta-argumento **`for_each`** é parecido com o count, mas em vez de um número, ele aceita uma coleção (pode ser uma lista ou um mapa). Com `for_each`, o Terraform criará uma instância do recurso para **cada elemento** da coleção fornecida. Isso nos permite controlar via chaves ou valores os recursos, o que é bem útil para endereçar cada instância por um identificador significativo ao invés de índice numérico.\n\n**INSTRUTOR:**\nExemplo: queremos criar instâncias para um conjunto de ambientes: digamos “dev”, “staging” e “prod”. Poderíamos usar `for_each` com uma lista desses nomes. Cada recurso instanciado terá uma chave correspondente ao elemento.\n\nNo editor:\n\n```hcl\nresource \"aws_instance\" \"servidor\" {\n  for_each      = toset([\"dev\", \"staging\", \"prod\"])\n  ami           = var.instance_ami\n  instance_type = var.instance_type\n\n  tags = {\n    Name = \"Servidor-${each.key}\"\n    Environment = each.key\n  }\n}\n```\n\n**INSTRUTOR:**\nAqui, utilizamos `for_each` e passamos um conjunto (usamos `toset([...])` para converter a lista em um set, embora lista também funcione, mas set garante elementos únicos e sem ordem). O Terraform vai criar três instâncias, mas em vez de índices, cada uma será identificada pelas chaves `“dev”`, `“staging”`, `“prod”`. Dentro do recurso, usamos `each.key` para obter o nome da chave atual (no caso igual ao ambiente) e personalizar algo, como a tag Environment.\n\n**INSTRUTOR:**\nPara referenciar depois, a gente acessaria `aws_instance.servidor[\"dev\"].id`, por exemplo, para pegar o ID da instância dev. O legal do `for_each` é que se a coleção é um mapa, podemos inclusive usar o valor, `each.value`, dentro. E se alterarmos a coleção removendo ou adicionando chaves, o Terraform sabe exatamente qual recurso remover ou adicionar baseando-se na chave, não causando recriação dos outros. Isso é mais estável que count quando lida com conjuntos dinâmicos.\n\n**INSTRUTOR:**\nEntão use `count` para coisas simples ou sequenciais fixas, e `for_each` quando quiser iterar sobre entidades nomeadas ou quando a estabilidade de identidade for importante.\n===encerramento da cena===\n---\n## CENA 5 – DEPENDS_ON: DEPENDÊNCIAS EXPLÍCITAS\nInstrutor próximo de dois recursos onde um depende do outro logicamente, mas sem referência direta no código.\n\n**INSTRUTOR:**\nPor padrão, o Terraform determina a ordem de criação dos recursos analisando as referências. Por exemplo, se um recurso A usa algum atributo de B, então B será criado antes de A automaticamente. Porém, há casos em que um recurso precisa acontecer antes de outro **sem** que haja uma referência explícita. Para esses casos, existe o meta-argumento **`depends_on`**.\n\n**INSTRUTOR:**\n`depends_on` aceita uma lista de recursos ou módulos que este recurso deve aguardar antes de criar ou destruir. Um caso comum: você tem um recurso que não depende de outro diretamente, mas por motivo de processo, quer forçar ordem. Por exemplo, talvez você queira criar primeiro toda a rede (VPC, subnets) antes de criar as instâncias, mesmo que seu código de instância já referencie a subnet (nesse caso até há referência). Um exemplo melhor: um null_resource (um recurso “nulo” usado só para triggers) que executa alguma ação após vários recursos estarem prontos – você colocaria depends_on para todos eles.\n\nExemplo sintético:\n\n```hcl\nresource \"aws_instance\" \"example\" {\n  # ... config ...\n  depends_on = [\n    aws_security_group.sg_padrao,\n    null_resource.configuracao_inicial\n  ]\n}\n```\n\n**INSTRUTOR:**\nNo exemplo, dizemos que a instância `example` só deve ser criada depois de um `aws_security_group.sg_padrao` e de um `null_resource.configuracao_inicial`. Mesmo que não usemos nada desses dentro da instância, o Terraform garantirá a ordem. Esse recurso é útil para provisioners externos organizados em null_resources (por exemplo, executar algo somente após infraestrutura X estar toda criada).\n\n**INSTRUTOR:**\nUse depends_on apenas quando necessário – muitos iniciantes pensam que precisam explicitamente para tudo, mas lembre: Terraform já descobre a maioria das dependências. Use para casos excepcionais onde não há referência direta mas a ordem importa.\n===encerramento da cena===\n---\n## CENA 6 – LIFECYCLE: REGRAS DE CICLO DE VIDA\nInstrutor perto de um símbolo de proteção (para prevent_destroy) e de setas trocadas (create_before_destroy).\n\n**INSTRUTOR:**\nO meta-argumento **`lifecycle`** permite ajustar comportamentos especiais na forma como o Terraform trata a criação/atualização/remoção de recursos. Dentro de `lifecycle` podemos definir algumas opções, das quais as mais usadas são: `prevent_destroy`, `create_before_destroy` e `ignore_changes`.\n\n**INSTRUTOR:**\n`prevent_destroy`: impede que o Terraform destrua o recurso, mesmo que o código seja removido ou alterado para isso. Se alguém tentar aplicar uma mudança que removeria o recurso, vai dar erro ao invés de destruí-lo. Útil para recursos críticos que você nunca quer deletar por engano (ex: banco de dados de produção). Você pode setar `prevent_destroy = true` para garantir isso – caso precise destruir propositalmente, teria que remover essa flag temporariamente.\n\n**INSTRUTOR:**\n`create_before_destroy`: por padrão, se você mudar uma propriedade que requer substituição do recurso (Terraform indica com “-/+” no plano), o Terraform primeiro destrói o antigo e depois cria o novo, para recursos que não podem coexistir duplicados. Com `create_before_destroy = true`, você instrui o Terraform a tentar a estratégia inversa: criar o novo primeiro, transferir dependências, depois destruir o antigo. Isso minimiza downtime, mas nem sempre é possível (se o provedor não deixar duas existências, ou se esbarrar em limites). Ainda assim, para recursos que suportam duplicação temporária, é muito útil pra trocas sem interrupção.\n\n**INSTRUTOR:**\n`ignore_changes`: lista de atributos do recurso que o Terraform deve **ignorar** se forem alterados fora do Terraform ou mesmo no código. Por exemplo, se um campo é gerenciado manualmente ou por outro processo e você não quer que o Terraform tente reconciliar. Um caso típico: talvez alguém costuma ajustar uma tag manualmente no console – se não quiser que Terraform fique toda hora removendo ou acusando drift, você ignora a tag no código. Ou recursos como timestamp de última modificação que muda automaticamente – ignorá-los evita ruído. Use com cautela, pois ignorar changes pode fazer Terraform perder mudanças importantes, mas em alguns cenários é necessário.\n\nMostrar um snippet de exemplo de lifecycle:\n\n```hcl\nresource \"aws_s3_bucket\" \"files\" {\n  # ... config normal do bucket ...\n\n  lifecycle {\n    prevent_destroy     = true\n    ignore_changes      = [ \"tags\" ]\n  }\n}\n```\n\n**INSTRUTOR:**\nNo exemplo, temos um bucket S3 que marcamos com `prevent_destroy = true` – assim, alguém não vai apagá-lo via Terraform sem intenção. E definimos para ignorar mudanças em tags (talvez para permitir edição livre de tags no console sem Terraform reclamar). Se precisássemos trocar esse bucket por outro sem downtime, poderíamos usar `create_before_destroy` também, mas S3 tem restrição de nome global, então nem sempre funcionaria, é situacional.\n\n**INSTRUTOR:**\nO `lifecycle` pode ter outras opções dependendo do recurso/provedor, porém essas são as gerais do Terraform. Novamente, usar com critério: `prevent_destroy` em recursos críticos, `create_before_destroy` onde faz sentido e `ignore_changes` só quando algo externo interfere ou você deliberadamente quer que Terraform não mexa em certo atributo.\n===encerramento da cena===\n---\n## CENA 7 – META-ARGUMENTOS EM MÓDULOS\nInstrutor comenta brevemente que meta-args também valem para blocos module.\n\n**INSTRUTOR:**\nVale mencionar: alguns meta-argumentos como `count`, `for_each` e `depends_on` também podem ser usados em blocos de módulo e até provisioners de módulos – ou seja, você pode ter múltiplas instâncias de um módulo usando count/for_each, assim como faria com um recurso. Isso permite, por exemplo, criar 3 módulos de VPC idênticas para 3 ambientes apenas com count, em vez de copiar e colar module calls. Da mesma forma, `depends_on` pode garantir que um módulo inteiro execute depois de outro.\n===encerramento da cena===\n---\n## CENA 8 – ENCERRAMENTO\nCena final recapitula visualmente os meta-argumentos discutidos: uma lista multiplicada (count), itens iterados (for_each), seta de dependência (depends_on), e um escudo (lifecycle).\n\n**INSTRUTOR:**\nHoje exploramos meta-argumentos do Terraform: `count` e `for_each` para gerar recursos de forma dinâmica e escalável, `depends_on` para ajustar ordem de criação quando necessário, e `lifecycle` para controlar políticas de criação/destruição e ignorar mudanças específicas. Esses recursos nos ajudam a escrever configurações mais poderosas e seguras.\n\n**INSTRUTOR:**\nCom `count` e `for_each`, vimos que podemos reduzir ainda mais repetição e gerar infraestruturas de acordo com listas ou mapas de entrada. Com isso e módulos combinados, conseguimos modelar cenários complexos (por exemplo, criar N recursos similares modulados por uma lista de configurações). A essa altura, você já domina a maior parte do Terraform para criar infra de forma eficiente.\n\n**INSTRUTOR:**\nNo próximo e último tutorial da série, vamos cobrir **Funções e Expressões** do Terraform – coisas como usar funções built-in para manipular strings e listas, e escrever expressões condicionais ou laços. Isso complementa tudo que aprendemos, dando o toque final de lógica ao seu código. Vejo você em breve para finalizar nossa série com chave de ouro!\n\nEncerra com a tela exibindo um trecho de código elegante usando meta-argumentos, simbolizando a eficiência alcançada.\n===fade out==="
  },
  {
    "id": "fae198a8-04cc-43f6-a6a2-b273245fda26",
    "titulo": "Funções e expressões",
    "nivel": "iniciante",
    "ferramenta": "Terraform",
    "conteudo": "## CENA 1 – RECAPITULAÇÃO\nClipes dos episódios passados passam em sequência rápida: instalação, primeiro recurso, variáveis, state, provisioners, módulos, meta-argumentos – mostrando a progressão da série.\n\n**INSTRUTOR:**\nChegamos ao último episódio da nossa série Terraform! Até aqui, cobrimos desde os fundamentos até recursos avançados como módulos e meta-argumentos. Para fechar com chave de ouro, vamos explorar as **Funções e Expressões** do Terraform. São ferramentas que permitem manipular dados e adicionar lógica dentro dos arquivos .tf de forma declarativa.\n===encerramento da cena===\n---\n## CENA 2 – ABERTURA\nNa tela, aparece código Terraform com exemplos de funções: conversão de strings, concatenação, condição ternária, e loops de lista. Animações mostram entradas sendo transformadas em saídas.\n\n**INSTRUTOR:**\nBem-vindo ao Tutorial 8! Hoje vamos falar de **Funções Built-in** do Terraform e expressões como condicionais e loops. Embora o Terraform não seja uma linguagem de programação imperativa, ele fornece uma linguagem de expressão bem poderosa para que possamos calcular valores, formatar strings, fazer decisões condicionais e gerar estruturas complexas. Isso ajuda a deixar nossas configurações mais dinâmicas e adaptáveis sem precisar editar manualmente valores.\n\n**INSTRUTOR:**\nVamos ver exemplos práticos de uso de funções (como manipular strings, listas, mapas, criptografias), usar condicionais ternários para valores que dependem de condições e utilizar expressões de loop para construir listas ou mapas dentro do código. Com isso, você poderá escrever configurações Terraform mais inteligentes.\n===encerramento da cena===\n---\n## CENA 3 – FUNÇÕES BUILT-IN\nInstrutor aparece em frente a uma lista de categorias de funções: Strings, Numéricas, Lista/Map, Datas, etc._  \n**INSTRUTOR:**\nO Terraform possui **diversas funções built-in** que podem ser chamadas nas expressões. Elas servem para transformar e combinar valores. Vamos por categoria alguns exemplos comuns:\n\n**INSTRUTOR:**\n**Funções de String**: permitem manipular texto. Por exemplo, `lower(\"ABC\")` resulta em `\"abc\"` (tudo minúsculo), `upper(\"dev\")` vira `\"DEV\"`, `concat(\"a\",\"b\")` junta strings resultando em `\"ab\"`. Outra útil: `replace(\"Hello, World\", \"World\", \"Terraform\")` substitui ocorrências, produzindo `\"Hello, Terraform\"`. Também temos `substr(string, offset, length)` para pegar substring.\n\n**INSTRUTOR:**\n**Funções Numéricas e lógicas**: `abs(-5)` dá 5 (valor absoluto), `max(1, 5, 3)` retorna 5, `min(...)` o mínimo. Existe `ceil` e `floor` para arredondar números (em contextos que suportam float). Lógica booleana não tem funções dedicadas além de operadores (`&&`, `||`, etc.), mas existe, por exemplo, a possibilidade de usar ternário que já vamos ver.\n\n**INSTRUTOR:**\n**Funções de Coleções (listas/sets/mapas)**:\n```\n    - `length(list or map)` – devolve o tamanho de uma lista ou map.\n    - `tolist(...)` e `tomap(...)` – convertem para tipos list ou map apropriados.\n    - `merge(map1, map2, ...)` – mescla mapas.\n    - `keys(map)` – obtém lista de chaves de um mapa, `values(map)` pega lista de valores.\n    - `element(list, index)` – pega elemento de lista pelo índice (pode ser útil com count index).\n    - `flatten(list_of_lists)` – achata uma lista de listas em uma única lista.\n```\n\n**INSTRUTOR:**\n**Funções de codificação/decodificação**:\n```\n    - `base64encode(string)` e `base64decode(string)` – para trabalhar com Base64.\n    - `jsonencode(value)` – converte uma estrutura Terraform (lista/mapa) em JSON (string). Útil se um recurso requer JSON embutido.\n    - `jsondecode(string)` – o inverso, para ler JSON como map/estrutura.\n```\n\n**INSTRUTOR:**\n**Funções de Datas**:\n```\n    - `timestamp()` – retorna a data/hora atual em UTC (formato RFC3339).\n    - `formatdate(spec, timestamp)` – formata timestamp de acordo com um especificador.\n    - `timeadd(timestamp, duration)` – adiciona uma duração (tipo “30m”, “1h”) a um timestamp.\n```\n\n**INSTRUTOR:**\nEsses são só alguns exemplos; há muitas outras funções (criptográficas, de rede, etc). A documentação oficial tem uma lista completa. Vamos ver alguns exemplos práticos integrados com nosso código.\n===encerramento da cena===\n---\n## CENA 4 – EXEMPLOS PRÁTICOS DE FUNÇÕES\nNo editor, o instrutor demonstra pequenos usos de funções em contextos plausíveis:\n\n**INSTRUTOR:**\nSuponha que queremos garantir que um nome de bucket S3 fique em letras minúsculas (já que S3 não permite maiúsculas). Podemos fazer:\n\n```hcl\nresource \"aws_s3_bucket\" \"dados\" {\n  bucket = lower(var.nome_do_bucket)\n  # ... restante ...\n}\n```\n\n**INSTRUTOR:**\nAqui, qualquer que seja o valor em var.nome_do_bucket (talvez vindo do usuário), garantimos que `lower()` vai transformar pra minúsculo antes de usar no nome do bucket. Simples e eficaz.\n\n**INSTRUTOR:**\nOutro exemplo: digamos que queremos concatenar o nome do ambiente com um prefixo para formar um nome de recurso:\n\n```hcl\nvariable \"ambiente\" {\n  type = string\n}\nresource \"aws_cloudwatch_log_group\" \"logs\" {\n  name = \"${var.ambiente}-app-logs\"\n}\n```\n\n**INSTRUTOR:**\nNo exemplo acima, usei interpolação `${}` (que internamente usa concat ou format) para criar uma string. Note: A partir do Terraform 0.12, podemos concatenar strings simplesmente escrevendo `\"${var.ambiente}-app-logs\"`. Antigamente usaríamos a função `format(\"%s-app-logs\", var.ambiente)` ou o operador `join`, mas a sintaxe de interpolação já é suficiente e clara. Importante: se estivermos só juntando static e dynamic, isso funciona. Para listas de strings, tem a função `join(\"sep\", list)` que une elementos com um separador.\n\n**INSTRUTOR:**\nE se quisermos algo condicional? Por exemplo, escolher uma AMI diferente se o ambiente for `prod` vs se for `dev`. Poderíamos usar uma expressão condicional (ternária):\n\n```hcl\nvariable \"ambiente\" { }\nvariable \"ami_dev\" { }\nvariable \"ami_prod\" { }\nresource \"aws_instance\" \"web\" {\n  ami = var.ambiente == \"prod\" ? var.ami_prod : var.ami_dev\n  # ... outros params ...\n}\n```\n\n**INSTRUTOR:**\nEsse trecho define: se o ambiente for “prod”, usa a AMI de produção, senão usa a de dev. O operador `condition ? true_val : false_val` permite essa lógica inline. Bastante útil para parâmetros que mudam conforme ambiente ou alguma opção booleana. Por exemplo, poderíamos ter uma variável booleana `enable_monitoring`, e usar: `count = var.enable_monitoring ? 1 : 0` num recurso de monitoramento – assim, se true cria um recurso, se false não cria (utilizando count conforme comentamos antes).\n===encerramento da cena===\n---\n## CENA 5 – EXPRESSÕES FOR (LOOP)\nNo editor, mostra o uso da expressão for para construir um novo conjunto a partir de outro.\n\n**INSTRUTOR:**\nAlém das funções, Terraform tem **expressões de for** para construir listas ou mapas a partir de outras coleções – é como um list comprehension em Python, se você conhece, ou um laço de transformação funcional. Elas têm esta sintaxe:\n\n**INSTRUTOR:**\n_Para listas_: `[ for ITEM in LIST : EXPRESSION ]` – isso itera sobre cada item de LIST e produz uma nova lista de resultados da EXPRESSION, onde você pode usar `ITEM`.\n\n**INSTRUTOR:**\n_Para maps_: `{ for KEY, VAL in MAP : KEY => NEWVALUE }` – itera sobre cada par de um mapa, permitindo produzir um novo mapa possivelmente alterando as chaves ou valores.\n\n**INSTRUTOR:**\nExemplo prático: imagine que temos uma variável lista de portas e queremos gerar regras de firewall para cada porta. Poderíamos fazer um recurso com for_each, ou simplesmente preparar uma lista formatada das portas com protocolo para passar em um campo. Usando for comprehension:\n\n```hcl\nvariable \"ports\" {\n  type = list(number)\n  default = [80, 443]\n}\nlocals {\n  ports_formatted = [ for p in var.ports : \"${p}/tcp\" ]\n}\n```\n\n**INSTRUTOR:**\nAqui, `locals` definimos uma variável local calculada chamada `ports_formatted`. Usamos um for para iterar cada porta em var.ports e produzir uma string `<porta>/tcp`. Se var.ports = [80,443], o resultado será `[\"80/tcp\", \"443/tcp\"]`. Poderíamos então usar `local.ports_formatted` em algum recurso de segurança ou output.\n\n**INSTRUTOR:**\nOutro uso: digamos que, a partir de uma lista de nomes, queremos mapear para um objeto com nome e ambiente. Podemos usar for para produzir um mapa:\n\n```hcl\nvariable \"nomes_servidores\" {\n  default = [\"web\", \"db\"]\n}\nlocals {\n  servidores_map = {\n    for nome in var.nomes_servidores :\n    nome => \"${nome}-${var.ambiente}\"\n  }\n}\n```\n\n**INSTRUTOR:**\nIsso pegaria os nomes, por exemplo [\"web\",\"db\"], e produziria um mapa: {\"web\": \"web-dev\", \"db\": \"db-dev\"} (supondo ambiente dev). Estamos usando o nome como chave e combinando com ambiente para o valor. Esse tipo de construção poderia alimentar um for_each de um recurso, por exemplo, criar instâncias nomeadas com sufixo do ambiente. Notar que no for map eu omiti explicitamente o segundo valor (`for nome in list` sem especificar value, nesse caso each item _é_ o key e eu defino o value após =>). Se fosse um map original, seria `for k, v in some_map : ...`.\n\n**INSTRUTOR:**\nDá até para filtrar dentro dessas expressões for acrescentando um `if` no final para condicionar que itens incluir. Ex: `[ for num in var.numeros : num * 2 if num > 5 ]` – isso dobraria apenas os números maiores que 5.\n===encerramento da cena===\n---\n## CENA 6 – DYNAMIC BLOCKS (MENÇÃO RÁPIDA)\nNota: dynamic block could be advanced, but maybe mention briefly.\n\n**INSTRUTOR:**\nUm recurso relacionado a expressões que vale a menção rápida é o bloco **dynamic**. Algumas vezes, precisamos gerar _sub-blocos_ dentro de um recurso de forma dinâmica. Ex: recursos que suportam múltiplos blocos `ingress` de segurança. Se quiséssemos basear isso numa lista, podemos usar a sintaxe dynamic:\n\n```hcl\nresource \"aws_security_group\" \"example\" {\n  name = \"example\"\n\n  dynamic \"ingress\" {\n    for_each = var.ports\n    content {\n      from_port = ingress.value\n      to_port   = ingress.value\n      protocol  = \"tcp\"\n      cidr_blocks = [\"0.0.0.0/0\"]\n    }\n  }\n}\n```\n\n**INSTRUTOR:**\nEsse snippet indica: para cada porta em var.ports, criará um bloco ingress dentro do security_group com aquela porta como from_port e to_port. O `ingress.value` refere-se ao valor corrente (similar each.value dentro). O termo 'ingress' depois de dynamic é o tipo de bloco que estamos gerando. Isso é mais avançado e na verdade muitas vezes dá para contornar usando recurso separado ou múltiplas definições, mas dynamic block é bom quando o número de sub-blocos varia conforme variáveis.\n===encerramento da cena===\n---\n## CENA 7 – BOAS PRÁTICAS COM FUNÇÕES E EXPRESSÕES\nInstrutor dá conselhos de uso.\n\n**INSTRUTOR:**\nÉ empolgante ter lógica no código Terraform, mas lembre-se: mantenha as expressões o mais simples possível para que o código seja legível para você e sua equipe. Se empilhar muitas funções dentro de uma só linha, pode ficar confuso. Às vezes é melhor quebrar em `locals` para nomes intermediários. Por exemplo, se vai usar um jsonencode de algo composto, atribua a uma local var com nome claro e então use. Locals são variáveis locais calculadas que você pode definir no seu módulo para ajudar na organização e evitar repetição de expressões complexas.\n\n**INSTRUTOR:**\nOutra prática: tentar fazer lógica muito elaborada dentro do Terraform pode indicar que talvez você deveria gerar o Terraform via outra linguagem ou template em casos extremos. Mas para a maioria das necessidades, as funções e expressões do Terraform cobrem bem a dinâmica necessária em IaC, então aproveite-as.\n===encerramento da cena===\n---\n## CENA 8 – ENCERRAMENTO DA SÉRIE\nA câmera agora foca no instrutor (ainda narrador off-screen) encerrando não só o episódio mas toda a série. Mostra um panorama dos tópicos cobertos e uma infraestrutura exemplar configurada via Terraform.\n\n**INSTRUTOR:**\nParabéns! Você chegou ao fim da nossa série de tutoriais Terraform. Neste último capítulo, aprendemos a usar funções e expressões para dar mais poder ao nosso código. Vimos como transformar dados com funções (strings, listas, mapas, etc.), aplicar lógicas condicionais e loops para evitar repetição e tornar configurações dependentes de valores de entrada. Isso complementa tudo que aprendemos, permitindo escrever infraestrutura como código de forma declarativa, modulada e inteligente.\n\n**INSTRUTOR:**\nRecapitulando brevemente nossa jornada: começamos preparando o ambiente e instalando o Terraform, então aprendemos a criar recursos básicos e os comandos fundamentais. Em seguida, introduzimos variáveis e outputs para flexibilizar, exploramos o state do Terraform para entender o funcionamento interno, usamos provisioners para configurações pós-provisionamento, reorganizamos tudo em módulos reutilizáveis, aplicamos meta-argumentos para controle avançado, e finalmente utilizamos funções e expressões para deixar o código mais dinâmico. Ufa!\n\n**INSTRUTOR:**\nCom esse conhecimento, você já pode iniciar projetos Terraform do zero até um nível intermediário-avançado com segurança. Claro, há sempre mais a aprender – o Terraform continua evoluindo e há tópicos que não cobrimos em detalhes (como Terraform Cloud, Workspace, importações avançadas, etc). Mas os pilares estão todos aqui.\n\n**INSTRUTOR:**\nEspero que tenha gostado dessa jornada cinematográfica pelo mundo do Terraform. Agora é a sua vez: pratique, experimente em um ambiente de teste, destrua e crie infraestruturas sem medo (desde que sejam controladas!). Revisite os vídeos quando precisar relembrar algum conceito. A infraestrutura como código é poderosa e você deu um grande passo para dominá-la.\n\n**INSTRUTOR:**\nMuito obrigado por assistir a essa série até o final. Nos vemos em outras oportunidades e bons deploys com Terraform! Até a próxima.\n\nCena final: A logo do Terraform aparece centralizada enquanto as imagens de código e infra se dissolvem, encerrando a série de tutoriais.\n===fade out==="
  },
  {
    "id": "283dee82-b238-4044-a207-26d3b4e0efe4",
    "titulo": "Preparar o ferramental e ambiente",
    "nivel": "iniciante",
    "ferramenta": "CloudFormation",
    "conteudo": "**CENA 1 - Introdução**  \n_(Uma música inspiradora toca suavemente. A câmera abre em um ambiente de escritório tecnológico. Vemos uma mesa organizada com um laptop exibindo o logotipo da AWS na tela. Diagramas de infraestrutura em nuvem estão sutilmente dispostos nas paredes. Uma luz de tela ilumina o rosto de alguém fora de quadro, sugerindo que o instrutor está pronto para iniciar. A atmosfera é de expectativa e aprendizado.)_\n\n**NARRADOR:** (voz confiante, em off) \n\"Olá e seja bem-vindo à nossa série de tutoriais sobre **AWS CloudFormation**. Nesta jornada em oito partes, vamos aprender a automatizar a criação de infraestrutura na AWS usando **infraestrutura como código**. No episódio de hoje, vamos **preparar o ferramental e o ambiente** para nossos projetos. Antes de botar a mão na massa, precisamos garantir que tudo esteja configurado corretamente para que possamos seguir em frente sem imprevistos.\"\n\n**CENA 2 - Apresentação do Ambiente**  \n_(Corte para uma tomada frontal do laptop na mesa. Na tela, o site da AWS é aberto. A câmera faz um zoom suave no botão \"Create an AWS Account\". Em seguida, aparecem cortes rápidos do download de um instalador e de uma janela de terminal com texto se preenchendo, indicando a instalação de ferramentas. Ícones de software conhecidos, como um editor de código e o AWS CLI, surgem ao redor da tela, destacando os itens necessários.)_\n\n**NARRADOR:** \n\"Para começar, **você vai precisar de uma conta AWS**. Se ainda não tiver, acesse o site da AWS e **crie uma conta gratuita**. Depois de logar, vamos configurar as credenciais de acesso. Instale a ferramenta de linha de comando **AWS CLI** e, em seguida, execute `aws configure` no terminal. Insira sua **Access Key ID**, **Secret Access Key**, região padrão e o formato de saída de sua preferência. Com isso, seu computador passa a ter permissão para realizar implantações na nuvem em seu nome.\"\n\n**NARRADOR:** \n\"Além da CLI, é útil ter um bom **editor de textos ou IDE** para escrever os templates do CloudFormation. Você pode usar, por exemplo, o **Visual Studio Code** com a extensão de YAML ou até plugins específicos do CloudFormation para realce de sintaxe e validação de templates. Não se esqueça de instalar também o **cfn-lint**, uma ferramenta de lint para verificar erros nos seus arquivos de template. Assim, ganhamos agilidade e evitamos erros de formatação.\"\n\n**NARRADOR:** \n\"Com a conta criada e as credenciais configuradas, escolha uma **região AWS** adequada para os testes (como `us-east-1` ou outra de sua preferência). Verifique se sua conta tem permissões para criar os recursos de exemplo. Como vamos usar o CloudFormation, é ideal ter privilégios de administrador ou permissões específicas para serviços que serão provisionados. Tudo pronto no ambiente? Ótimo! Seu ambiente de desenvolvimento de infraestrutura está configurado. Podemos seguir adiante.\"\n\n**CENA 3 - Encerramento**  \n_(A câmera se afasta lentamente do laptop, mostrando novamente o panorama do escritório com os diagramas na parede. As luzes se ajustam para um tom mais brilhante, sinalizando conclusão desta etapa. Surge na tela o título \"Ferramental e Ambiente Prontos\".)_\n\n**NARRADOR:** \n\"Com o ferramental instalado e o ambiente configurado, concluímos nosso primeiro passo. Neste tutorial, preparamos o terreno para trabalhar com templates do CloudFormation. Nos próximos episódios, começaremos a construir nossas soluções na nuvem passo a passo. **No próximo tutorial**, você vai conhecer o AWS CloudFormation em si, entender seus conceitos fundamentais e ver como ele pode simplificar a gestão da sua infraestrutura. Até lá!\"\n\n_(Tela escurece com um breve fade-out, encerrando o Tutorial 1.)_"
  },
  {
    "id": "275cf7b7-c912-4e60-bc02-7b21f3bd1956",
    "titulo": "Introdução ao AWS CloudFormation",
    "nivel": "iniciante",
    "ferramenta": "CloudFormation",
    "conteudo": "**CENA 1 - Recapitulação Rápida**  \n_(Uma vinheta sonora breve indica o início do recap. Surge o texto \"Anteriormente...\" no canto da tela. Imagens rápidas dos episódios passados aparecem em sequência:)_\n\n- _Imagem 1: O instrutor configurando o AWS CLI no terminal e inserindo credenciais (do Tutorial 1)._\n- _Imagem 2: A tela de um editor de código pronta para escrever templates, com o logo do CloudFormation aparecendo (transição para o Tutorial 2)._\n\n**NARRADOR:** (tom de lembrança) \n\"No último episódio, preparamos nosso ambiente de desenvolvimento: criamos a conta AWS, instalamos o AWS CLI e deixamos nossas ferramentas a postos. Agora que tudo está pronto, é hora de conhecer a estrela da série: **o AWS CloudFormation em si**.\"\n\n**CENA 2 - Introdução do Tutorial 2**  \n_(Fade-in para uma animação do logotipo do AWS CloudFormation girando no centro da tela, como se fosse o emblema de abertura. Ao fundo, vê-se uma nuvem de símbolos de serviços AWS interconectados por linhas, representando infraestrutura. A câmera se move através dessa nuvem de ícones, parando ao centro no logo do CloudFormation.)_\n\n**NARRADOR:** \"Bem-vindo ao Tutorial 2. Hoje faremos uma **introdução ao AWS CloudFormation**. Pense no CloudFormation como um arquiteto digital da AWS. Em vez de clicar manualmente em consoles para criar máquinas virtuais, redes e bancos de dados, você descreve tudo em um arquivo de texto chamado **template** e o CloudFormation constrói a infraestrutura para você. Parece mágica? Vamos descobrir como funciona.\"\n\n**CENA 3 - Explicação dos Conceitos**  \n_(A imagem muda para o desenho de dois cenários lado a lado. Do lado esquerdo, um personagem clicando em várias janelas de console AWS para criar recursos. Do lado direito, o mesmo resultado sendo obtido através de um documento de texto com código. Acima do lado direito, aparece o ícone do CloudFormation orquestrando tudo.)_\n\n**NARRADOR:** \"Criar infraestrutura manualmente, serviço por serviço, pode ser **demorado e propenso a erros**. Imagine ter que repetir esse processo toda vez que precisar replicar o ambiente em outra região ou montar o mesmo conjunto de recursos para teste e produção. Com o **AWS CloudFormation**, definimos todos os recursos e suas configurações em um template. Com um único comando ou clique, podemos implantar uma **pilha** completa de recursos em questão de minutos, de forma consistente e reproduzível.\"\n\n**NARRADOR:** \"O CloudFormation utiliza a abordagem de **Infraestrutura como Código (IaC)**. Isso significa que a infraestrutura da nuvem é tratada como software: versionada, revisada e automatizada. Cada template pode criar uma ou mais **pilhas** de recursos. Uma **pilha (stack)** nada mais é do que o conjunto de recursos AWS definidos no template, implantados e gerenciados como uma unidade. Por exemplo, você pode ter uma pilha que representa toda a infraestrutura de um aplicativo web – contendo servidores EC2, bancos de dados RDS, buckets S3, etc. – tudo criado a partir de um único template.\"\n\n**NARRADOR:** \"Quando você solicita ao CloudFormation para criar uma pilha a partir de um template, ele **lê as configurações** e comunica-se com os vários serviços da AWS para instanciar cada recurso na ordem correta, levando em conta dependências automaticamente. Se um recurso deve ser criado antes de outro (como uma VPC antes de instâncias dentro dela), o CloudFormation cuida disso para você. Ele também garante rollback automático: se algo falhar no meio da criação, ele pode reverter as mudanças para evitar ficar com infraestrutura parcial.\"\n\n_(Enquanto o narrador fala, visualizações ilustram esses pontos: ícones de recursos conectados por setas numeradas indicando ordem de criação, seguido de um ícone de \"rollback\" mostrando uma seta circular indicativa de reversão.)_\n\n**NARRADOR:** \"Os templates do CloudFormation podem ser escritos em **YAML ou JSON**. Neste treinamento, usaremos YAML pela sua legibilidade. Dentro de um template, há seções bem definidas para organizar as informações: por exemplo, você pode especificar parâmetros de entrada, os recursos que serão criados, configurações fixas através de mapeamentos, condições lógicas para criação condicional de recursos, e valores de saída. Não se preocupe, vamos explorar **cada uma dessas seções nos próximos tutoriais**.\"\n\n**NARRADOR:** \"Resumindo, o AWS CloudFormation nos permite automatizar e padronizar implantações. **Ao invés de dezenas de passos manuais**, temos **um único artefato (o template)** que produz a infraestrutura desejada de forma segura e repetível. Isso aumenta a produtividade e evita discrepâncias de configuração. A seguir, vamos ver o CloudFormation em ação com um exemplo simples, para fixar esses conceitos.\"\n\n**CENA 4 - Demonstração Rápida**  \n_(A tela limpa dá lugar ao Console AWS CloudFormation aberto no navegador. O instrutor (fora de cena) navega para a opção \"Create stack\". Uma janela é exibida pedindo pelo upload de um template.)_\n\n**NARRADOR:** \"Vamos supor que queremos criar um bucket S3 através de um template. No console do CloudFormation, clicamos em **Create Stack (Criar Pilha)** e fornecemos nosso arquivo de template. O CloudFormation então nos perguntará alguns detalhes, como o nome da pilha e possíveis parâmetros, e em seguida construirá tudo. Em poucos instantes, o bucket estará criado, conforme descrito no código.\"\n\n_(Vemos a barra de progressão no console criando os recursos e, logo, um ícone de confirmação verde indicando sucesso. Em seguida, a câmera foca no nome do bucket listado.)_\n\n**NARRADOR:** \"Claro, aqui estamos apenas introduzindo o conceito. Nos próximos episódios, nós mesmos vamos **escrever templates** e criar pilhas de exemplo. Mas já deu para sentir o poder dessa ferramenta. Agora que entendemos o **que é o CloudFormation e por que usá-lo**, estamos prontos para aprofundar nas partes que compõem um template. No **próximo tutorial**, começaremos pela **Parametrização**, aprendendo a tornar nossos templates reutilizáveis e flexíveis.\"\n\n**CENA 5 - Encerramento**  \n_(A imagem do console do CloudFormation minimiza para dar lugar ao logo do AWS CloudFormation novamente ao centro, cercado agora pelos dizeres \"Tutorial 2 Concluído\". Fogos de artifício digitais sutis aparecem ao fundo, simbolizando a conquista do conhecimento básico.)_\n\n**NARRADOR:** \"Encerramos aqui o Tutorial 2. Você aprendeu a ideia central do CloudFormation e como ele pode agilizar a criação de infraestrutura. Nos vemos em breve no próximo vídeo, onde começaremos a colocar esses conceitos em prática adicionando **parâmetros** aos nossos templates. Até lá!\"\n\n_(Fade-out enquanto a música de encerramento toca.)_"
  },
  {
    "id": "bf04f741-e014-4eab-a3bd-d2bfceb8fe31",
    "titulo": "Parametrização",
    "nivel": "iniciante",
    "ferramenta": "CloudFormation",
    "conteudo": "**CENA 1 - Recapitulação**  \n_(Uma trilha rápida toca. No estilo \"Previously on...\", flashes dos episódios anteriores cobrem a tela:)_\n\n- _Imagem do Tutorial 1: O terminal mostrando `aws configure` e a configuração do ambiente concluída._\n- _Imagem do Tutorial 2: O console do CloudFormation exibindo uma pilha criada com sucesso._\n\n**NARRADOR:** (tom relembrando e empolgado) \"Nos tutoriais anteriores, preparamos o ambiente e conhecemos os conceitos fundamentais do CloudFormation. Vimos como um template descreve infraestrutura e como o CloudFormation orquestra esses recursos em uma pilha. Agora, seguiremos em frente aprendendo a tornar nossos templates mais **reutilizáveis e dinâmicos**.\"\n\n**CENA 2 - Introdução do Tutorial 3**  \n_(Fade em uma cena de um editor de texto aberto em tela cheia, com um arquivo YAML do CloudFormation. Algumas linhas de código estão visíveis, mas espaços em branco sugerem partes a serem preenchidas. No topo do editor, uma seção intitulada \"Parameters:\" está presente, mas ainda sem conteúdo. A câmera faz um leve zoom nessa seção.)_\n\n**NARRADOR:** \"Bem-vindo ao **Tutorial 3: Parametrização**. Hoje vamos aprender como deixar nossos templates mais flexíveis usando **parâmetros**. Imagine que no último exemplo criamos um bucket S3 com configurações fixas. E se quisermos reutilizar o mesmo template para criar buckets com nomes ou regiões diferentes? É aí que entram os parâmetros: eles são **valores de entrada** que podemos definir a cada criação de pilha, sem precisar alterar o template em si.\"\n\n**CENA 3 - Explicação de Parâmetros**  \n*(A câmera passeia pelo código YAML no editor. Surgem linhas de exemplo conforme o narrador descreve. Por exemplo:\n\n```\nParameters:\n  BucketName:\n    Description: \"Nome do bucket S3\"\n    Type: String\n    Default: \"meu-bucket\"\n```\n\nO código aparece destacando as partes mencionadas.)*\n\n**NARRADOR:** \"No CloudFormation, a seção `Parameters` do template serve para **declarar entradas personalizáveis**. Cada parâmetro tem um nome lógico e propriedades como tipo, descrição e valor padrão. Por exemplo, podemos declarar um parâmetro chamado **BucketName** com `Type` definido como `String`. Podemos fornecer uma `Description` para orientar o usuário, e talvez um `Default` - um valor padrão - caso nenhum valor seja especificado. Também podemos restringir os inputs com opções como `AllowedValues` (lista de valores permitidos) ou `AllowedPattern` (expressão regular para validar o formato). Isso garante que quem for criar a pilha insira dados válidos.\"\n\n_(O editor agora mostra um exemplo completo de parâmetro, incluindo AllowedValues, enquanto o narrador fala. Em paralelo, do lado direito da tela aparece a representação visual: um formulário de criação de pilha destacando o campo de input para \"BucketName\".)_\n\n**NARRADOR:** \"Digamos que o parâmetro **EnvironmentType** aceite os valores 'dev' ou 'prod'. Podemos definir `AllowedValues: [dev, prod]` para limitar as escolhas. No console do CloudFormation, quando o usuário for criar a pilha, verá um campo para 'EnvironmentType' e poderá selecionar um dos valores permitidos. Os parâmetros nos permitem usar **um único template em cenários diferentes**. Você não precisa manter dois arquivos quase iguais para ambientes distintos – basta definir as diferenças via parâmetros.\"\n\n**NARRADOR:** \"Outra funcionalidade útil é especificar tipos de parâmetro fornecidos pela AWS. Por exemplo, se você utilizar o tipo _AWS::EC2::KeyPair::KeyName_ em um parâmetro, o CloudFormation exibirá automaticamente a lista de KeyPairs EC2 existentes na sua conta para seleção. Isso facilita a entrada e evita erros, pois o usuário não precisa lembrar ou digitar o nome exato do recurso.\"\n\n_(A câmera foca agora em como o parâmetro é referenciado dentro do template. No editor de código, o cursor desce para a seção de recursos (Resources). Vemos um trecho onde o nome do bucket S3 é definido usando `Ref: BucketName` ao invés de um valor fixo. Este trecho do código é destacado.)_\n\n**NARRADOR:** \"Após declarar os parâmetros, você pode **referenciá-los dentro do template**. A forma de fazer isso é usando a função intrínseca `Ref`. Sempre que usamos `Ref` seguido do nome lógico do parâmetro (por exemplo, `!Ref BucketName` no YAML), o CloudFormation insere ali o valor fornecido pelo usuário. No nosso exemplo do bucket S3, se definirmos o nome do bucket como `Ref: BucketName`, ao criar a pilha o CloudFormation substituirá isso pelo nome efetivo passado no momento da criação.\"\n\n**NARRADOR:** \"Vamos visualizar um caso concreto: Nosso template tem um parâmetro chamado **InstanceType** para definir o tipo de instância EC2 (t2.micro, t3.medium etc.). Na seção de recursos, ao criar um recurso `AWS::EC2::Instance`, referenciamos `InstanceType` com `!Ref InstanceType` para configurar a propriedade _InstanceType_ da máquina. Assim, com o mesmo template, podemos lançar instâncias pequenas para testes ou maiores para produção, apenas variando o parâmetro no momento do deploy.\"\n\n_(A tela agora mostra lado a lado duas execuções do mesmo template: na esquerda, o usuário passou InstanceType=t2.micro; na direita, InstanceType=t3.medium. A esquerda exibe uma instância pequena sendo criada e na direita uma maior, ilustrando cenários dev vs prod.)_\n\n**NARRADOR:** \"Percebe como a parametrização traz flexibilidade? **Templates parametrizados** são como formulários: você preenche os campos e obtém uma infraestrutura adaptada à sua necessidade. Isso promove **reuso** – escrever um template uma vez e aplicá-lo em vários contextos. Além disso, torna seu código mais limpo, separando o que é estrutura (no template fixo) do que é variável (nos inputs fornecidos). Em suma, parâmetros permitem ajustar facilmente quantidade de recursos, nomes, tamanhos e outras características sem mexer no código fonte do template.\"\n\n**CENA 4 - Demonstração Prática de Parâmetros**  \n_(A câmera foca novamente no Console do CloudFormation. O instrutor inicia a criação de uma pilha usando um template que contém parâmetros. Na tela \"Specify stack details\", campos correspondentes aos parâmetros definidos aparecem. O instrutor preenche esses campos com valores de exemplo.)_\n\n**NARRADOR:** \"Aqui está a **demonstração**: no console, ao criar uma pilha a partir de um template parametrizado, somos solicitados a preencher os parâmetros. Por exemplo, digito o nome do bucket conforme desejado, seleciono o tipo de instância de uma lista predefinida... Depois de lançar a pilha, o CloudFormation aplica esses valores. Se olharmos o template em si, não precisaremos alterá-lo para cada variação – apenas fornecemos entradas diferentes.\"\n\n_(A tela mostra a pilha sendo criada com sucesso. Em seguida, o narrador acessa a seção \"Parameters\" dentro dos detalhes da pilha criada, mostrando os valores que foram efetivamente usados.)_\n\n**NARRADOR:** \"Após a criação, é possível verificar no **detalhe da pilha** quais valores foram usados para cada parâmetro, o que documenta a instância daquele deploy. Isso ajuda no controle e auditoria. E se precisarmos atualizar a infraestrutura, podemos **atualizar a pilha** fornecendo novos valores de parâmetro. O CloudFormation fará as mudanças incrementais necessárias para atingir a nova configuração.\"\n\n**CENA 5 - Encerramento**  \n_(A câmera se afasta do monitor, voltando a uma visão mais ampla do ambiente de trabalho, com o editor de código e o console AWS ao fundo. Os elementos na tela se organizam, e aparece um texto resumindo: \"Parametrização - Template Flexível\".)_\n\n**NARRADOR:** \"Hoje aprendemos a adicionar **parametrização** aos nossos templates, transformando-os em ferramentas versáteis. No próximo tutorial, continuaremos construindo nosso conhecimento e vamos focar no coração do template: a seção de **Recursos**, onde definimos quais objetos na AWS serão criados. Vejo você no próximo episódio!\"\n\n_(Fade-out suave enquanto a música de fundo conclui a apresentação.)_"
  },
  {
    "id": "96425b4b-8992-4e5d-bbaa-efc251f85487",
    "titulo": "Recursos",
    "nivel": "iniciante",
    "ferramenta": "CloudFormation",
    "conteudo": "**CENA 1 - Recapitulação**  \n_(Som de introdução da recapitulação. A tela mostra breves trechos dos tutoriais anteriores:)_\n\n- _Do Tutorial 2: Um gráfico ilustrando vários recursos AWS conectados sob um template._\n- _Do Tutorial 3: O trecho de código YAML destacando `Parameters` e o uso de `!Ref` dentro de Resources._\n\n**NARRADOR:** (tom de narrador de série, relembrando) \"Até agora, configuramos nosso ambiente, entendemos o que é o CloudFormation, e já tornamos nossos templates dinâmicos com parâmetros. Com isso, garantimos que nossos modelos possam ser reutilizados em diferentes cenários. Chegou a hora de entrar na parte principal de qualquer template: **os Recursos**.\"\n\n**CENA 2 - Introdução do Tutorial 4**  \n_(Fade para uma visualização estilizada: uma folha de blueprint técnico se desenrola ocupando toda a tela. Sobre o blueprint, surgem ícones representando recursos AWS – um símbolo de servidor (EC2), um banco de dados (RDS), um balde (S3), etc. Esses ícones vão se posicionando ordenadamente, como se estivessem sendo desenhados no blueprint.)_\n\n**NARRADOR:** \"Seção **Recursos**... é aqui que a mágica realmente acontece. Bem-vindo ao **Tutorial 4**, onde exploraremos como declarar **Recursos** em um template do CloudFormation. Pense nos recursos como as peças de Lego de infraestrutura: instâncias de servidor, bancos de dados, redes, tópicos de fila, tudo o que você quiser criar na AWS precisa ser definido na seção `Resources` do seu template.\"\n\n**CENA 3 - Explicação dos Recursos**  \n*(A câmera aproxima do blueprint, enfocando um bloco intitulado \"Resources:\". Abaixo, aparece um exemplo em YAML de um recurso sendo definido. Por exemplo:\n\n```\nResources:\n  MeuBucket:\n    Type: AWS::S3::Bucket\n    Properties:\n      BucketName: !Ref BucketNameParam\n```\n\nO exemplo destaca o nome lógico, o tipo e as propriedades.)*\n\n**NARRADOR:** \"Cada recurso no template tem um **ID lógico**, um **tipo** e um conjunto de **propriedades**. O ID lógico é um nome que você escolhe para referenciar esse recurso dentro do template (por exemplo, _MeuBucket_). O tipo indica ao CloudFormation **que tipo de recurso AWS criar** – como `AWS::S3::Bucket` para criar um bucket S3, `AWS::EC2::Instance` para uma instância EC2, e assim por diante. E as propriedades são configurações específicas do recurso, equivalentes aos parâmetros que você preencheria manualmente se estivesse criando aquele recurso via console.\"\n\n**NARRADOR:** \"No exemplo, definimos um recurso `MeuBucket` do tipo S3 Bucket. Poderíamos especificar propriedades como o nome do bucket (nesse caso, usando o parâmetro `BucketNameParam` que já vem de uma seção de Parameters), versão, regras de lifecycle, etc. Se fosse um recurso de EC2, as propriedades poderiam incluir a AMI (imagem da máquina), o tipo de instância (t2.micro, etc.), chaves de acesso (KeyName), security groups, e por aí vai. **Cada tipo de recurso tem seu próprio conjunto de propriedades** permitidas, exatamente como você configuraria aquele serviço normalmente.\"\n\n_(Enquanto o narrador fala, a imagem no blueprint exibe diferentes exemplos de recursos: um bloco de código de um `AWS::EC2::Instance`, outro de um `AWS::RDS::DBInstance`, etc., com algumas propriedades visíveis para ilustrar.)_\n\n**NARRADOR:** \"Ao criar recursos, é importante lembrar que eles podem referenciar uns aos outros. Por exemplo, você cria primeiro uma VPC e depois quer criar subnets dentro dela; ou cria um tópico SNS e atrela uma função Lambda a esse tópico. Dentro de um template, podemos usar referências para conectar recursos: usando `Ref` para pegar o nome ou ID de um recurso, ou `Fn::GetAtt` para obter um atributo específico de um recurso (como o endereço IP de uma instância, ou o ARN de uma função). O CloudFormation entende essas relações e **automaticamente ordena a criação** conforme as dependências. Você não precisa sequenciar manualmente – basta referenciar corretamente que ele garante que o recurso referenciado exista antes.\"\n\n_(A tela mostra uma ilustração de dependência: um diagrama com caixas \"VPC\" e depois \"Subnet\", com uma seta indicando que a Subnet depende da VPC. Em código, aparece algo como `!Ref VPCID` dentro do recurso Subnet, evidenciando a ligação.)_\n\n**NARRADOR:** \"Outro ponto: **recursos opcionais.** Às vezes, queremos que determinados recursos sejam criados apenas em certas condições – como um ambiente de produção ter dois servidores em load balance, e desenvolvimento ter apenas um. Embora esse seja assunto do Tutorial 7 (Condições), já vale saber que podemos condicionar recursos inteiros. No blueprint imaginário, é como traçar um recurso a lápis e dizer 'só finalize este desenho se tal condição for atendida'. Em seguida veremos detalhes de como usar isso, mas é bom ter em mente enquanto adicionamos recursos.\"\n\n**NARRADOR:** \"Uma vez definido todos os recursos no template, ao criar a pilha, o CloudFormation provisionará cada um deles. Ele também acompanha o estado: espera cada criação completar, e só então passa para as próximas, ou reverte caso uma falhe. No final, se tudo der certo, você terá todos esses recursos rodando na sua conta AWS, visíveis tanto no console de cada serviço quanto listados no console do CloudFormation como parte da pilha.\"\n\n**CENA 4 - Demonstração de Criação de Recurso**  \n_(Agora vemos o editor de código e o console lado a lado. O instrutor copia um trecho de um template YAML (já pronto) com vários recursos definidos – por exemplo, uma instância EC2 e um Security Group – e cola no console do CloudFormation via opção de \"Design Template\" ou upload do arquivo. Inicia a criação da pilha.)_\n\n**NARRADOR:** \"Vamos a uma demonstração prática. Aqui tenho um template que define dois recursos: uma instância EC2 e um Security Group associado. O Security Group é referenciado pela instância, então o CloudFormation sabe que deve criar primeiro o SG, depois a EC2. Ao fazer upload desse template e criar a pilha, acompanhe no console as etapas...\"\n\n_(No console CloudFormation, a guia \"Events\" mostra as linhas: \"CREATE_IN_PROGRESS AWS::EC2::SecurityGroup\", depois \"CREATE_COMPLETE AWS::EC2::SecurityGroup\", em seguida \"CREATE_IN_PROGRESS AWS::EC2::Instance\", etc. Finalmente, \"CREATE_COMPLETE AWS::EC2::Instance\" e \"CREATE_COMPLETE AWS::CloudFormation::Stack\".)_\n\n**NARRADOR:** \"...Podemos ver que ele criou primeiro o Security Group, depois a instância. Tudo automático. Se clicarmos na aba de **Resources** da pilha, veremos a lista de recursos criados com sucesso, cada um com seu status e identidades (IDs) gerados. Isso mostra que nossos **recursos foram definidos corretamente** e agora existem na infraestrutura.\"\n\n_(A câmera mostra a aba de recursos da pilha, listando \"MyInstance\" e \"MySecurityGroup\" com status CREATE_COMPLETE, e exibindo seus Physical IDs.)_\n\n**NARRADOR:** \"Os Recursos formam o **coração do template**. São eles que materializam seu ambiente. Sempre que precisar adicionar algo novo – um outro servidor, um outro bucket – você vai editar essa seção. Mas e se quisermos **extrair informações** desses recursos, como o endpoint de um serviço criado, para uso externo? Para isso, usaremos a seção de **Outputs**, que é o tema do nosso próximo tutorial.\"\n\n**CENA 5 - Encerramento**  \n_(O blueprint na tela começa a encolher e se transforma no ícone do CloudFormation novamente. Ao redor do ícone, agora aparecem pequenos ícones representando saída (como um documento com uma seta saindo). Talvez um balão de diálogo com uma variável mostrada, simbolizando outputs.)_\n\n**NARRADOR:** \"Concluímos o Tutorial 4. Você viu como definir **Recursos** e percebeu que, juntamente com parâmetros, podemos construir templates robustos. No **próximo episódio**, aprenderemos a declarar **Outputs**, permitindo expor ou compartilhar valores resultantes da criação da pilha. Até lá, continue experimentando definir diferentes recursos em seus templates!\"\n\n_(Fade-out com a música de tema.)_"
  },
  {
    "id": "f8980583-8f72-4128-b94f-d0966b141417",
    "titulo": "Outputs",
    "nivel": "iniciante",
    "ferramenta": "CloudFormation",
    "conteudo": "**CENA 1 - Recapitulação**  \n_(A vinheta de recap pisca na tela junto com imagens rápidas:)_\n\n- _Tutorial 3: O formulário de parâmetros sendo preenchido no console._\n- _Tutorial 4: A aba de recursos de uma pilha mostrando recursos criados._\n\n**NARRADOR:** (animado, recapitulando) \"Até agora adicionamos parâmetros aos templates e definimos vários recursos que o CloudFormation pode criar. Você aprendeu a erguer a infraestrutura como código e torná-la flexível. Hoje, vamos ver como **extrair informações** daquela infraestrutura recém-criada por meio dos **Outputs** do CloudFormation.\"\n\n**CENA 2 - Introdução do Tutorial 5**  \n_(A cena abre com a imagem de um cofre se abrindo e dele saindo papéis com dados. Ao lado, aparece um stack de recursos e um balão indicando que algo sai dela. Essa animação representa a ideia de extrair outputs de uma pilha. O texto \"Outputs\" surge no topo.)_\n\n**NARRADOR:** \"Bem-vindo ao **Tutorial 5: Outputs**. Imagine que você acabou de criar uma pilha com diversos recursos – um deles é um Load Balancer, por exemplo – e quer obter o DNS público dele para divulgar. Ou talvez você precise do ID de uma instância EC2 para passar para outro script. Os **Outputs** do CloudFormation são a solução: eles permitem **expor valores** de dentro da pilha para fora, seja para visualização, para documentação ou até para serem usados em outras pilhas.\"\n\n**CENA 3 - Explicação de Outputs**  \n*(A câmera foca em um template aberto no editor, especificamente na seção `Outputs`. Vemos um exemplo sendo construído:\n\n```\nOutputs:\n  LoadBalancerDNS:\n    Description: \"URL de acesso ao Load Balancer\"\n    Value: !GetAtt MeuLoadBalancer.DNSName\n```\n\nO exemplo enfatiza Description e Value.)*\n\n**NARRADOR:** \"No template CloudFormation, a seção `Outputs` é onde declaramos **saídas**. Cada output tem um nome lógico (por exemplo, _LoadBalancerDNS_), que serve para identificá-lo, uma `Description` opcional para explicar do que se trata, e um `Value`, que é o valor a ser retornado. Esse valor geralmente vem de uma referência a algo criado na pilha – podemos usar `Ref` para pegar, por exemplo, o nome de um bucket S3 criado, ou usar funções intrínsecas como `Fn::GetAtt` (ou atalho `!GetAtt` no YAML) para obter um atributo específico de um recurso.\"\n\n**NARRADOR:** \"No exemplo que vemos, definimos um Output chamado _LoadBalancerDNS_. A descrição esclarece que é a URL de acesso, e o valor é definido como `!GetAtt MeuLoadBalancer.DNSName` – presumindo que temos um recurso de Load Balancer com ID lógico _MeuLoadBalancer_ e que ele possui o atributo _DNSName_. Assim, quando a pilha for criada, o CloudFormation capturará automaticamente o DNS do Load Balancer e disponibilizará esse valor como saída.\"\n\n_(No vídeo, podemos mostrar a relação: destacar no section de Resources um recurso \"MeuLoadBalancer\" e uma propriedade ou atributo, e no Outputs mostrar como aquele atributo é referenciado. Uma seta liga o recurso ao output.)_\n\n**NARRADOR:** \"Os outputs aparecem de forma bem visível após a criação da pilha. No Console AWS CloudFormation, ao selecionar a pilha, existe uma guia chamada **Outputs (Saídas)** onde cada saída é listada com seu valor. Você também pode obter os outputs via CLI, usando o comando `aws cloudformation describe-stacks` e procurando pelos outputs, ou ainda consumi-los programaticamente via API.\"\n\n_(Mostra a tela do console na guia Outputs após uma pilha criada; lá vemos por exemplo \"LoadBalancerDNS -> abcdef-elb.amazonaws.com\".)_\n\n**NARRADOR:** \"Para que servem essas saídas? Várias coisas:\n\n- **Facilitar acesso a informações importantes**: Em vez de ir em cada serviço procurar o identificador ou endpoint gerado, você já tem tudo consolidado. Isso é ótimo para documentar, por exemplo, a URL de um site lançado, ou o ARN de um tópico SNS, etc.\n- **Parâmetros para outros deployments**: Outputs podem ser usados como **exportações**. Você pode marcar um output com um nome de export (`Export: Name: NomeDoExport`) e então, em outra pilha (outro template), usar a função `Fn::ImportValue` para importar aquele valor. Dessa forma, consegue **integrar pilhas**. Por exemplo, uma pilha exporta o ID de uma VPC, e outras pilhas importam esse ID para criar recursos dentro da mesma VPC.\n- **Automação e scripts**: Ferramentas externas ou scripts de deploy podem ler os outputs para passar informações adiante. Se você está automatizando via pipeline CI/CD, no final do CloudFormation você pode capturar os outputs e, por exemplo, executar testes de integração apontando para o endpoint que foi retornado.\"\n\n_(Enquanto lista essas utilidades, aparecem pequenas vinhetas ilustrativas: um ícone de documento com check para documentação; duas pilhas com setas trocando um valor (representando import/export); e um símbolo de engrenagem para automação.)_\n\n**NARRADOR:** \"É importante ressaltar que os outputs **não devem ser usados para informação sensível**, como senhas, pois eles ficam visíveis para quem tem acesso à pilha (inclusive via API, sem criptografia). O CloudFormation não ofusca esses valores de saída. Então use outputs para dados que podem ser compartilhados livremente ou que sejam necessários para integrações, mas mantenha segredos de outra forma (como no AWS Secrets Manager ou usando parâmetros NoEcho, etc.).\"\n\n**CENA 4 - Demonstração de Outputs**  \n_(Agora o instrutor mostra um exemplo prático. No console, ele acessa uma pilha já criada que, por exemplo, lançou uma instância EC2. Na guia Outputs, nenhum output está presente inicialmente. Então ele edita o template daquela pilha (stack update) para incluir um output com o ID da instância ou IP público.)_\n\n**NARRADOR:** \"Vamos para um exemplo prático. Aqui tenho uma pilha que criou uma instância EC2. Inicialmente, não definimos nenhum output. Vou editar (atualizar) o template para adicionar uma saída: o **ID da instância** criada. Adiciono no template um output como este:\n\n```yaml\nOutputs:\n  InstanceId:\n    Description: \"ID da instância EC2\"\n    Value: !Ref MinhaInstanciaEC2\n```\n\nAo aplicar a atualização da pilha com esse novo output, veja o que acontece...\"\n\n_(Aplica-se a atualização. Após completar, o console agora mostra na guia Outputs: \"InstanceId -> i-0abcd1234ef567890\".)_\n\n**NARRADOR:** \"Agora a pilha exibe um output chamado InstanceId com o valor do ID real da instância gerada. Com esse ID, eu poderia por exemplo passar para outra pilha que configure algo adicional naquela instância, ou simplesmente ter fácil acesso ao identificador sem procurar nos detalhes do EC2.\"\n\n**NARRADOR:** \"Outputs também podem ser condicionais, sabia? Assim como é possível associar condições a recursos, podemos associar a um output, de modo que só seja emitido se determinada condição for verdadeira. A sintaxe é semelhante: adicionamos uma chave `Condition: NomeDaCondicao` no bloco do output. Isso é útil se, por exemplo, queremos exibir o URL de um Load Balancer apenas se o recurso Load Balancer foi realmente criado (ou seja, só em ambiente de produção, seguindo o exemplo anterior).\"\n\n_(O template de exemplo é mostrado com um output contendo `Condition: CreateProdResources` vinculado a ele, ilustrando essa possibilidade.)_\n\n**CENA 5 - Encerramento**  \n_(A imagem recua mostrando um sumário: na tela vemos, em colunas, um template com recursos e outputs de um lado e, do outro, um painel listando outputs resultantes com valores. Isso reforça a ideia de entrada e saída. Em seguida, surge o texto \"Outputs Concluídos\".)_\n\n**NARRADOR:** \"Encerramos o Tutorial 5. Agora você sabe como obter informações das suas pilhas usando Outputs, tornando seus deployments mais transparentes e integráveis. No **próximo tutorial**, exploraremos **Mapeamentos** (Mappings), que são uma forma de incorporar tabelas de dados fixas em seus templates para lidar com configurações específicas por região ou ambiente. Nos vemos lá!\"\n\n_(Fade-out, finalizando o tutorial.)_\n"
  },
  {
    "id": "a3a0d973-0226-4dc1-a1a5-aeea660b010b",
    "titulo": "Mapeamentos",
    "nivel": "iniciante",
    "ferramenta": "CloudFormation",
    "conteudo": "**CENA 1 - Recapitulação**  \n_(Introdução da recapitulação toca. Cenas dos episódios anteriores surgem rapidamente:)_\n\n- _Tutorial 4: Trecho de template mostrando dois recursos dependentes (e a ordem de criação automática)._\n- _Tutorial 5: A aba Outputs exibindo valores exportados da pilha._\n\n**NARRADOR:** (tom de retrospectiva) \"Na nossa jornada até aqui, já montamos templates com parâmetros, recursos e outputs. Nossas pilhas podem receber entrada e fornecer saída de dados. Agora, vamos adicionar um novo truque às nossas habilidades de template: **Mapeamentos**, para tornar as coisas ainda mais inteligentes.\"\n\n**CENA 2 - Introdução do Tutorial 6**  \n_(Tela abre exibindo um mapa-múndi estilizado. Sobre diferentes regiões do mapa aparecem símbolos representando configurações distintas – exemplo: na região EUA, um ícone de servidor com tipo \"t2.micro\"; na Europa, \"t3.micro\". Isso ilustra diferentes valores por região. O título \"Mappings\" surge acima do mapa.)_\n\n**NARRADOR:** \"Bem-vindo ao **Tutorial 6: Mapeamentos**. Muitas vezes, ao criar infraestrutura, há valores que variam conforme o contexto, mas **não são escolhidos pelo usuário e sim definidos pelo arquiteto do sistema**. Pense por exemplo nas AMIs (imagens de máquina) que são específicas de cada região, ou em diferentes tamanhos de instância recomendados conforme o ambiente. Podemos, é claro, pedir que o usuário passe esses detalhes via parâmetros... mas se quisermos simplificar e ter isso pré-definido no template? É aí que os **Mappings (Mapeamentos)** entram.\"\n\n**CENA 3 - Explicação de Mappings**  \n*(Em tela, o editor de código mostra a seção `Mappings` de um template. Aparece um exemplo:\n\n```yaml\nMappings:\n  RegionMap:\n    us-east-1:\n      \"InstanceType\": \"t2.micro\"\n    eu-west-1:\n      \"InstanceType\": \"t3.micro\"\n```\n\nO narrador destaca as partes: nome do mapping, chave de nível superior e chave-valor interno.)*\n\n**NARRADOR:** \"Mapeamentos são basicamente **tabelas estáticas de valores** embutidas no template. Eles funcionam como pares chave-valor de múltiplos níveis. Você define um Mapping com um nome lógico (no exemplo, _RegionMap_). Dentro dele, define chaves secundárias, e cada chave possui um conjunto de valores associados. No nosso caso, temos chaves de região ('us-east-1' e 'eu-west-1'), e para cada uma definimos um par nome/valor: aqui estamos mapeando `'InstanceType'` para um tipo específico de instância.\"\n\n**NARRADOR:** \"Com esse Mapeamento `RegionMap`, poderíamos, por exemplo, escolher automaticamente um tamanho de instância diferente dependendo da região onde a pilha está sendo criada. Note que, diferentemente dos parâmetros, isso **não é fornecido pelo usuário**; é logicado no template. Os mappings são úteis justamente quando **você, como autor do template, já conhece as variações** e quer aplicá-las automaticamente, sem expor a complexidade a quem está usando o template.\"\n\n_(A imagem do mapa-múndi volta à cena, agora com uma animação: quando o narrador menciona a diferença para parâmetros, o ícone de usuário some e as setas no mapa indicando valores por região são destacadas, mostrando que o controle está no template, não na entrada do usuário.)_\n\n**NARRADOR:** \"Como usamos um valor de mapping dentro do template? Através da função intrínseca `Fn::FindInMap`. Ela recebe três entradas: o nome do Mapping, a chave primária e a chave secundária, e devolve o valor correspondente. Por exemplo, se quisermos pegar o InstanceType do RegionMap para a região atual: `Fn::FindInMap(\"RegionMap\", \"<Região>\", \"InstanceType\")`. Mas qual <Região>? Aí entra uma sacada: podemos usar um **pseudoparâmetro** do CloudFormation chamado `AWS::Region`, que automaticamente preenche com a região onde a pilha está sendo implantada.\"\n\n*(No editor de código, surge um exemplo de uso: dentro de Resources, algo como:\n\n```yaml\nInstance:\n  Type: AWS::EC2::Instance\n  Properties:\n    InstanceType: !FindInMap [RegionMap, !Ref AWS::Region, InstanceType]\n```\n\nO narrador destaca esse trecho.)*\n\n**NARRADOR:** \"Veja este trecho: estamos definindo a propriedade InstanceType de uma instância EC2 usando `!FindInMap [RegionMap, !Ref AWS::Region, InstanceType]`. Aqui, `!Ref AWS::Region` insere a região atual (por exemplo, us-east-1), e então buscamos em RegionMap, na linha correspondente a us-east-1, o valor de InstanceType. Se a pilha estiver sendo criada na Virgínia (us-east-1), isso retornará t2.micro. Se for na Irlanda (eu-west-1), retornará t3.micro, conforme nosso mapping. Legal, não é?\"\n\n**NARRADOR:** \"Mapeamentos não se limitam a regiões. Você pode mapear qualquer coisa. Por exemplo, imagine que seu template atende três ambientes fixos: _dev_, _homolog_ e _prod_. Em vez de pedir que o usuário insira detalhes de configuração para cada um, você pode usar um parâmetro _Environment_ (com allowed values dev/homolog/prod) e um Mapping para cada ambiente definindo, por exemplo, quantidade de servidores, tamanhos, ou URIs de endpoints diferentes. Aí, usando FindInMap com o valor do parâmetro _Environment_, você obtém todos os detalhes específicos daquele ambiente.\"\n\n_(Surge um exemplo no editor de um Mapping chamado EnvConfig com chaves \"dev\", \"homolog\", \"prod\", e dentro de cada uma valores distintos para certas configurações, e o uso disso via FindInMap referenciando o parâmetro Environment.)_\n\n**NARRADOR:** \"É importante notar algumas características: as chaves em Mappings são **case-sensitive** e literais. Você **não pode** usar funções intrínsecas ou referências _dentro_ da definição do mapping; elas devem ser valores fixos. Ou seja, `Fn::FindInMap` só pode operar com chaves exatas. Mas você pode, claro, combinar parâmetros com mappings – como fizemos usando AWS::Region, ou poderia usar um parâmetro customizado como chave se fizesse sentido, desde que aquele parâmetro forneça um valor exato correspondente a uma chave do mapping.\"\n\n**CENA 4 - Demonstração de Mapping**  \n_(Agora, uma demonstração concreta. O instrutor abre um template que utiliza mappings. Por exemplo, um mapping de AMI IDs por região. Ele mostra o trecho do template com o mapping `AMIMap` e o uso dele em um recurso EC2 para escolher a AMI automaticamente. Em seguida, executa a criação da pilha em uma determinada região.)_\n\n**NARRADOR:** \"Vamos demonstrar com um caso real: **AMIs por região**. Tenho aqui um template com um mapping chamado _AMIMap_ que mapeia regiões da AWS para IDs de AMI específicos (digamos, para Amazon Linux 2 em cada região). O recurso EC2 no template usa `Fn::FindInMap` com `AMIMap` e a região atual para definir a AMI da instância. Quando eu criar a pilha, repare que eu **não informo a AMI em lugar algum** – o template cuida disso baseado na região.\"\n\n_(Ele inicia a pilha na região us-east-1. Após a criação, acessa os detalhes da instância EC2 criada e mostra que a AMI usada corresponde à que estava no mapping para us-east-1. Em seguida, repete a implantação na região eu-west-1 e mostra que a instância lá usou a AMI daquela região.)_\n\n**NARRADOR:** \"Após a criação da pilha na Virgínia (us-east-1), podemos verificar que a instância EC2 utilizou a AMI mapeada para us-east-1. Se eu fizer o mesmo na Europa (eu-west-1), a instância lá usará uma AMI diferente, correspondente àquela região, sem que eu tenha que alterar nada manualmente. O mapping dentro do template cuidou dessa lógica para nós.\"\n\n**NARRADOR:** \"Resumindo, Mapeamentos são ótimos para **encapsular lógica de configuração que não precisa ser exposta ao usuário**. Eles tornam o template mais inteligente, aplicando valores contextuais automaticamente. Com parameters, mappings e recursos combinados, já conseguimos muita flexibilidade. Mas às vezes precisamos de **lógica condicional mais complexa** do que um simples mapeamento. E para isso, o CloudFormation nos fornece as **Condições**, assunto do próximo tutorial.\"\n\n**CENA 5 - Encerramento**  \n_(O mapa-múndi com ícones se transforma gradualmente em um ícone de logica condicional (como um símbolo de IF). Aparece o texto \"Mapeamentos Concluídos\".)_\n\n**NARRADOR:** \"Chegamos ao fim do Tutorial 6. Exploramos os Mapeamentos e aprendemos a buscar valores estáticos de acordo com chaves. No **próximo episódio**, vamos elevar ainda mais nosso jogo, usando **Condições** para ativar ou desativar partes inteiras do template com base em critérios. Não perca, até lá!\"\n\n_(Fade-out com música de conclusão.)_\n"
  },
  {
    "id": "e1aeea47-d561-48ea-8dfd-13ad7615fb27",
    "titulo": "Condições",
    "nivel": "iniciante",
    "ferramenta": "CloudFormation",
    "conteudo": "**CENA 1 - Recapitulação**  \n_(Trilha de recapitulação. Imagens dos tutoriais anteriores aparecem:)_\n\n- _Tutorial 5: O template mostrando um output condicionado (com Condition) e o console exibindo outputs._\n- _Tutorial 6: Um trecho de mapping e a função Fn::FindInMap sendo usada para escolher valores._\n\n**NARRADOR:** (em tom de série dramática) \"Nos últimos tutoriais, aprimoramos nossos templates com entradas flexíveis e lógicas internas. Aprendemos a usar parâmetros para personalização e mapeamentos para ajustes automáticos. Agora, vamos abordar um recurso poderoso: as **Condições**, que permitem que um mesmo template se adapte a cenários diferentes habilitando ou omitindo partes conforme necessário.\"\n\n**CENA 2 - Introdução do Tutorial 7**  \n_(A cena inicial mostra duas versões de um diagrama de infraestrutura sobrepostas parcialmente: uma com menos componentes (representando talvez um ambiente simplificado) e outra mais completa (um ambiente robusto). Entre elas, um ícone de um interruptor liga/desliga ou um símbolo de condição (? :) aparecendo, indicando que há uma escolha. Título \"Condições\" na parte superior.)_\n\n**NARRADOR:** \"Bem-vindo ao **Tutorial 7: Condições**. Imagine poder usar o mesmo template para implantar um ambiente de **teste** ou de **produção**, mudando automaticamente a quantidade de recursos ou habilitando recursos extras apenas quando necessário. As **Condições** do CloudFormation fazem exatamente isso: elas determinam sob quais circunstâncias certos recursos, propriedades ou outputs devem ser criados.\"\n\n**CENA 3 - Explicação de Condições**  \n*(O editor de código exibe uma seção `Conditions` em destaque. Surge um exemplo:\n\n```yaml\nParameters:\n  EnvironmentType:\n    Type: String\n    Default: \"dev\"\n    AllowedValues: [\"dev\", \"prod\"]\n\nConditions:\n  CreateProdResources: !Equals [ !Ref EnvironmentType, \"prod\" ]\n```\n\nO narrador destaca a condição e seu significado.)*\n\n**NARRADOR:** \"No CloudFormation, definimos condições na seção `Conditions` do template. Cada condição avalia a uma expressão booleana (verdadeiro ou falso) no momento da criação ou atualização da pilha. Geralmente, condições comparam valores de parâmetros ou pseudo parâmetros. No exemplo mostrado, temos um parâmetro _EnvironmentType_ que pode ser 'dev' ou 'prod'. Definimos a condição **CreateProdResources** que usa a função intrínseca `Fn::Equals` (atalho `!Equals` no YAML) para verificar se o _EnvironmentType_ passado é igual a 'prod'. Se for, a condição é verdadeira (ou seja, estamos em ambiente de produção); se não, é falsa.\"\n\n**NARRADOR:** \"Uma vez declarada, essa condição pode ser **associada a recursos ou outputs**. Como fazemos isso? Muito simples: nos recursos ou outputs que queremos tornar condicionais, adicionamos a chave `Condition: CreateProdResources` (usando o nome lógico da condição) no seu bloco de definição. Assim, o CloudFormation **só criará aquele recurso se a condição for verdadeira**. Se a condição for falsa, aquele recurso é ignorado (não é criado) durante a implantação da pilha.\"\n\n*(O editor de código rola para a parte de Resources e mostra, por exemplo:\n\n```yaml\nResources:\n  EC2BackupServer:\n    Type: AWS::EC2::Instance\n    Condition: CreateProdResources\n    Properties:\n      InstanceType: t3.large\n      ...\n```\n\nO recurso inteiro tem a linha Condition, indicando que ele só será criado se CreateProdResources for true.)*\n\n**NARRADOR:** \"No exemplo, temos um recurso `EC2BackupServer` com a condição `CreateProdResources`. Isso significa que **somente em deploys de produção** essa instância extra de backup será criada. Em ambientes de dev ou homolog (onde EnvironmentType != prod), o CloudFormation pula esse recurso – como se ele nem existisse no template para aquele lançamento específico.\"\n\n**NARRADOR:** \"Condições não servem apenas para recursos inteiros. Elas também podem ser aplicadas a **propriedades individuais** dentro de um recurso, usando a função `Fn::If`. Com `Fn::If` podemos escolher um valor para uma propriedade caso a condição seja verdadeira ou outro caso seja falsa. A sintaxe do `Fn::If` recebe: o nome da condição, o valor se true, o valor se false. Isso é útil quando você quer criar sempre o recurso, mas talvez com configurações diferentes dependendo do cenário.\"\n\n*(É exibido um trecho de propriedades com Fn::If, por exemplo: definindo o tamanho de instância baseado em condição:\n\n```yaml\nProperties:\n  InstanceType: !If [ CreateProdResources, \"m5.large\", \"t2.micro\" ]\n```\n\nAssim, se produção escolhe m5.large, senão t2.micro.)*\n\n**NARRADOR:** \"Acima temos um exemplo de `Fn::If`: estamos definindo o InstanceType de uma instância condicionalmente – se CreateProdResources for true, usamos **m5.large** (um tipo maior para produção); se for false (ou seja, dev), usamos **t2.micro** (menor e mais barato). Dessa forma, não precisamos criar ou deixar de criar a instância em si; só alteramos como ela é configurada segundo o tipo de ambiente.\"\n\n**NARRADOR:** \"Também podemos condicionar **outputs**. Lembra do nosso output do Load Balancer no tutorial passado? Poderíamos envolver sua definição em uma condição para só exibi-lo se o recurso do Load Balancer foi criado. Isso evita mostrar um output vazio em casos em que determinado recurso não existe.\"\n\n_(Destaca-se a sintaxe mencionada anteriormente: dentro do output adicionar `Condition: CreateProdResources` por exemplo.)_\n\n**NARRADOR:** \"Internamente, o CloudFormation avalia todas as condições no início da criação ou atualização da pilha. Primeiro, ele resolve os parâmetros e pseudoparâmetros, depois calcula cada condição (true/false). Só então, ao processar a criação de recursos, ele já sabe quais ignorar e em quais propriedades aplicar as variações. O interessante é que se você posteriormente **atualizar a pilha** mudando o valor que afeta a condição, o CloudFormation pode criar ou remover recursos para alinhar ao novo estado. Por exemplo, se numa atualização você mudar EnvironmentType de 'dev' para 'prod', a condição passa a ser verdadeira e aqueles recursos marcados com a condição serão então criados durante a atualização. O inverso também ocorre: se algo que antes era true passa a false e aquele recurso existia, o CloudFormation pode eliminá-lo, já que a condição agora não é mais satisfeita.\"\n\n_(Para ilustrar, mostra uma timeline: na criação inicial EnvironmentType=dev (condição false) então recurso de backup não existe. Em uma atualização, EnvironmentType muda para prod (condição true) então aparece uma nova ação de criar o recurso de backup. Talvez com um rótulo \"Update: creating new backup server as condition now true\".)_\n\n**NARRADOR:** \"Essa capacidade de adaptação torna os templates **altamente reutilizáveis e controláveis**. Você pode manter uma única definição para múltiplos cenários, ativando features on-demand. Contudo, use condições com cuidado: às vezes muitos caminhos condicionais podem dificultar a manutenção do template. É bom usá-las quando realmente faz sentido evitar duplicação de código de template.\"\n\n**CENA 4 - Demonstração de Condições**  \n_(Demonstração prática: o instrutor mostra um template simples com uma condição e um recurso condicional. Em seguida, vai ao console criar a pilha com param dev e depois com param prod.)_\n\n**NARRADOR:** \"Vamos testar um exemplo. Nosso template tem um parâmetro _EnvironmentType_ e uma condição _CreateProdResources_ que checa se é 'prod'. Temos dois recursos EC2 definidos: um sempre existe (o servidor principal) e outro só existe se CreateProdResources for true (um servidor extra de monitoramento, digamos). Primeiro, vou criar a pilha definindo EnvironmentType=dev.\"\n\n_(No console, cria a stack com EnvironmentType=dev. Após a criação, ele mostra na aba Resources que apenas o recurso principal está lá; o recurso condicional não aparece na lista.)_\n\n**NARRADOR:** \"Como esperado, em ambiente de desenvolvimento, apenas o servidor principal foi criado. O recurso de monitoramento, condicionado a produção, foi ignorado. Agora, vamos atualizar esta mesma pilha mudando o parâmetro EnvironmentType para 'prod'.\"\n\n_(Ele faz uma stack update alterando o parâmetro. Durante a atualização, observa-se nos eventos que um novo recurso (monitoring server) entra em criação e é adicionado. Depois da conclusão, na aba Resources agora constam dois recursos.)_\n\n**NARRADOR:** \"Após a atualização para prod, o CloudFormation avaliou novamente as condições, viu que CreateProdResources agora é verdadeira, e **incluiu o recurso adicional** na nossa pilha. Temos agora os dois servidores. Se voltássemos para dev numa atualização futura, o CloudFormation deletaria aquele recurso extra para refletir a condição falsa. Toda essa lógica acontece de forma declarativa, sem que precisemos manualmente criar ou apagar recursos - basta alterar os parâmetros e o CloudFormation concilia a infraestrutura ao novo estado desejado.\"\n\n**CENA 5 - Encerramento**  \n_(A cena final mostra o template como um todo com parâmetros, mappings, conditions, resources e outputs, enfatizando como o arquivo agora parece completo e capaz de lidar com múltiplas situações. O texto \"Condições Concluídas\" aparece.)_\n\n**NARRADOR:** \"Fechamos o Tutorial 7 com chave de ouro: agora você domina **Condições** em templates CloudFormation. Isso encerra os principais blocos de construção de templates (parâmetros, recursos, outputs, mapeamentos e condições). No **próximo e último episódio**, vamos abordar o CloudFormation **Drift**, ou **Desvio**, um recurso que ajuda a detectar alterações fora do controle do CloudFormation. Até breve no último capítulo da série!\"\n\n_(Fade-out, anunciando o episódio final.)_"
  },
  {
    "id": "24ff5329-b305-43b3-8f9e-a12521f44c9d",
    "titulo": "CloudFormation Drift",
    "nivel": "iniciante",
    "ferramenta": "CloudFormation",
    "conteudo": "**CENA 1 - Recapitulação**  \n_(Trilha sonora de recap mais intensa, indicando que chegamos ao final. Imagens-chave de vários tutoriais anteriores passam como flash: o ambiente configurado, um template sendo escrito, pilha sendo criada, outputs exibidos, mapping selecionando valores, condição decidindo um recurso. Tudo em rápida sucessão.)_\n\n**NARRADOR:** (tom reflexivo e conclusivo) \"Ao longo desta série, construímos uma base sólida em AWS CloudFormation: configuramos nosso ambiente, aprendemos a escrever templates com parâmetros, recursos, outputs, mapeamentos e condições. Temos agora a habilidade de criar infraestrutura como código de forma rica e adaptável. Para encerrar, vamos falar de um aspecto crucial na manutenção dessas pilhas ao longo do tempo: o **Drift do CloudFormation**.\"\n\n**CENA 2 - Introdução do Tutorial 8**  \n_(A cena de abertura mostra um relógio acelerado indicando passagem de tempo e, ao fundo, uma representação de infraestrutura (uma pilha de recursos) desvanecendo ou se alterando gradativamente sem intervenção visível, simbolizando que mudanças aconteceram. Aparece um triângulo de alerta próximo a um dos recursos no diagrama. O título \"CloudFormation Drift (Desvios)\" surge.)_\n\n**NARRADOR:** \"Bem-vindo ao **Tutorial 8: CloudFormation Drift**. Com o tempo, é comum que uma infraestrutura passe por mudanças. Idealmente, todas as alterações seriam feitas via CloudFormation – você atualizaria o template e aplicaria as mudanças. **Mas e se alguém modificar um recurso manualmente** pela console ou CLI, fora do CloudFormation? Essas alterações fogem do controle do template original, e a sua pilha pode ficar **fora de sincronia** com o que o CloudFormation acha que existe. Esse fenômeno é chamado de **drift**, ou **desvio**.\"\n\n**CENA 3 - Explicação e Demonstração do Drift**  \n_(A câmera agora mostra lado a lado o template de uma pilha e a representação real da infraestrutura. Inicialmente, eles estão idênticos. Depois, uma mão (figura metafórica) aparece e muda um parâmetro de um recurso fora do template – por exemplo, muda manualmente a configuração de um Security Group ou altera o tamanho de uma instância via console AWS. Agora, a imagem do lado da infraestrutura real não corresponde mais ao template. Um ponto de interrogação aparece sobre o template, indicando discrepância.)_\n\n**NARRADOR:** \"Vamos ilustrar: você criou uma pilha com um Security Group que libera a porta 80. Dias depois, alguém, numa tentativa de resolver um problema urgente, vai direto no console do EC2 e abre também a porta 22 nesse Security Group, **sem passar pelo CloudFormation**. Pronto, temos um drift. O template original não sabe dessa porta 22 aberta – se você olhar o template, ele ainda mostra apenas a porta 80. A infraestrutura real derivou do estado esperado.\"\n\n**NARRADOR:** \"O AWS CloudFormation fornece uma funcionalidade para **detectar desvios**: o _Drift Detection_. Com ela, podemos pedir para o CloudFormation analisar a pilha atual e comparar cada recurso (que suporta essa verificação) com o que está definido no template armazenado. Ele então relata quais recursos estão em desvio e em que exatamente eles diferem.\"\n\n_(Mostra na tela o console do CloudFormation com uma pilha selecionada. O narrador guia: \"Stack actions > Detect drift (Detectar desvio)\". Uma barra de progresso aparece. Depois, exibe a seção onde os resultados são mostrados: alguns recursos marcados como \"MODIFIED\", \"IN_SYNC\", etc. Por exemplo, no nosso caso, o Security Group seria marcado \"MODIFIED\".)_\n\n**NARRADOR:** \"No Console do CloudFormation, ao selecionar a pilha, podemos escolher a opção _Detectar desvio_ (**Detect drift**). O CloudFormation então realiza a análise. Isso pode levar alguns instantes dependendo do número de recursos. Após concluído, ele atualiza o **status de desvio** da pilha e de cada recurso. Se nenhum desvio for encontrado, você verá a indicação de que tudo está _In Sync_ (em conformidade). Se houver desvios, a pilha será marcada como desviada e recursos específicos terão status como _MODIFIED_ (modificado), _DELETED_ (se algo definido no template foi excluído manualmente) ou _NOT CHECKED_ (para recursos que não suportam drift detection).\"\n\n_(O narrador clica em \"View drift results\". A tela exibe uma lista: Resource X - Drift status: MODIFIED. Resource Y - Drift status: IN_SYNC. etc. Seleciona o Security Group marcado como MODIFIED e clica em \"View drift details\". Aparece um diff das propriedades: no template, porta 80; no atual, porta 80 e 22 destacadas.)_\n\n**NARRADOR:** \"Vamos ver os detalhes: nosso Security Group aparece como **MODIFIED**. Ao ver os detalhes do desvio, o CloudFormation nos mostra que a diferença está nas regras de inbound: o template esperava apenas a porta 80, mas atualmente há 80 e 22. Ele destaca que a porta 22 é uma propriedade **a mais** presente no real e ausente no template. Esse insight é muito valioso. **Agora sabemos exatamente o que está diferente** do pretendido.\"\n\n**NARRADOR:** \"O CloudFormation **não corrige automaticamente** esses desvios – ele apenas os detecta e informa. Cabe a você, como desenvolvedor, decidir como resolver. As opções comuns são:\n\n- **Atualizar o template** para incluir a mudança legítima (por exemplo, adicionar a porta 22 no template) e depois aplicar uma atualização na pilha para regularizar.\n- **Reverter a alteração manual** diretamente no recurso para alinhar de volta com o template (por exemplo, remover a porta 22 via console ou CLI, já que não está no template).\n- Ou ainda, se o recurso driftado não é mais necessário segundo o template, você pode optar por excluí-lo via CloudFormation ou manualmente, dependendo do caso.\n\nO importante é restaurar a sincronização, seja ajustando o código ou a infraestrutura.\"\n\n_(Enquanto o narrador fala, são mostrados ícones representando essas ações: um lápis escrevendo em um documento (atualizar template), uma seta voltando atrás (reverter manual), e um ícone de exclusão.)_\n\n**NARRADOR:** \"Existe também a possibilidade de que um recurso no template tenha sido excluído manualmente. Nesse caso, o drift resultaria em status **DELETE** para esse recurso, e a pilha também seria considerada desviada. A resolução poderia ser recriar o recurso (via update do CloudFormation) ou remover do template se não for mais necessário e atualizar a pilha formalmente.\"\n\n**NARRADOR:** \"Você pode rodar a detecção de drift via linha de comando também, usando comandos como `aws cloudformation detect-stack-drift` e `aws cloudformation describe-stack-drift-detection-status` para acompanhar, e então `aws cloudformation describe-stack-resource-drifts` para obter os detalhes dos recursos desviados. Isso pode ser integrado em scripts de auditoria periódica, por exemplo.\"\n\n_(Na tela, aparecem janelas de terminal mostrando o uso desses comandos em sequência, e trechos do output JSON com drift statuses. Apenas visível brevemente para ilustrar a automação.)_\n\n**NARRADOR:** \"O Drift Detection é suportado para muitos, mas não todos, tipos de recurso. A AWS está constantemente expandindo essa lista. Ao detectar drift, recursos não suportados simplesmente virão marcados como 'NOT CHECKED' e você terá que verificar manualmente se suspeitar de algo. Apesar dessas limitações, essa funcionalidade é uma aliada importante para **governança da infraestrutura**. Ela ajuda a garantir que o que foi definido como código permanece a fonte da verdade do ambiente.\"\n\n**CENA 4 - Conclusão e Encerramento da Série**  \n_(A câmera agora se afasta da tela do computador e nos traz de volta à visão do escritório de onde iniciamos lá no primeiro tutorial. Os diagramas na parede e o laptop no centro. É noite lá fora, indicando que a jornada foi longa. O instrutor (ainda off-screen) fecha seu editor de texto e consola, satisfeito. Aparece na tela os dizeres \"Fim do Treinamento CloudFormation\".)_\n\n**NARRADOR:** \"Com o conhecimento de **Drift**, encerramos nosso oitavo e último tutorial. Hoje você aprendeu a importância de monitorar desvios entre o estado real e o declarado e como usar o CloudFormation para detectar essas discrepâncias. Mais do que uma ferramenta técnica, isso reforça as boas práticas de administrar infraestrutura como código: sempre que possível, faça mudanças via CloudFormation e, se precisar fazer algo manual em emergência, lembre-se de depois ajustar seu template para refletir a mudança.\"\n\n**NARRADOR:** \"Parabéns por chegar até aqui! Recapitulando nossa jornada: começamos preparando o ambiente, passamos pelos conceitos básicos do CloudFormation, dominamos parâmetros, recursos, outputs, mapeamentos e condições, e concluímos aprendendo a manter tudo alinhado com drift detection. Com esses conhecimentos, você está pronto para construir infraestruturas complexas de forma repetível, segura e controlada. **Obrigado por nos acompanhar** nesta série de treinamentos em CloudFormation.\"\n\n**NARRADOR:** \"Espero que tenha gostado e que esses vídeos tenham sido úteis. Nos vemos em próximos conteúdos! Boas implementações e até a próxima.\"\n\n_(A câmera focaliza o logotipo da AWS mais uma vez na tela do laptop, enquanto as luzes do cenário diminuem gradualmente. A música de encerramento sobe, e então a tela escurece lentamente, fechando a série de tutoriais.)_"
  }
];